#Include 'TOTVS.CH'
#INCLUDE "FINA171.CH"
#INCLUDE "FWMVCDEF.CH"
#DEFINE DECIMALDECALCULO 12           

Static bLoadGrd := {}
Static aCampos  := {}
Static cNumero  := ""
Static _oXFINA171
Static cCodFor	:= ""
Static cForLj	:= ""

/*/



Ŀ
Funo     XFINA171   Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio  Programa de atualizao de Aplicacoes/Emprestimos          
Ĵ
Sintaxe    XFINA171()                                                  
Ĵ
 Uso       SIGAFIN                                                    
ٱ


/*/
user Function XFinA171(nPosArotina)

//Declaracao de variaveis Multimoeda

Local lPanelFin := IsPanelFin()
Local nA := 0
Local nC	:=	MoedFin()
Local cMoedaTx

private aCuotas := {} // Nahim 03/12/2019
Private aTxMoedas	:=	{} 
//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada       
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
//Ŀ
// Parametros do Programa                                       
//                                                              
// MV_PAR01 : Mostra Lanc. Contabil                             
// MV_PAR02 : Contabiliza On-Line                               
//                                                              
//
Aadd(aTxMoedas,{"",1,PesqPict("SM2","M2_MOEDA1")})
For nA	:=	2	To nC
	cMoedaTx	:=	Str(nA,IIf(nA <= 9,1,2))
	If !Empty(GetMv("MV_MOEDA"+cMoedaTx))
		Aadd(aTxMoedas,{GetMv("MV_MOEDA"+cMoedaTx),RecMoeda(dDataBase,nA),PesqPict("SM2","M2_MOEDA"+cMoedaTx) })
	Else
		Exit
	Endif
Next

Private aRotina := MenuDef()

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro := OemToAnsi(STR0006)  //"Atual.Aplicaoes/Emprst."
//Ŀ
// Verifica o numero do Lote                                    
//
PRIVATE cLote
LoteCont("FIN")
//Ŀ
// Carrega funcao Pergunte                                      
//
SetKey(VK_F12,{||Fa171Perg()})
Pergunte("AFI171",.F.)
//Ŀ
// Endereca a funcao de BROWSE                                  
//

DEFAULT nPosArotina := 0
If nPosArotina > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
	dbSelectArea("SEH")
	bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e) }" )
	Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina)
Else
	mBrowse( 6, 1,22,75,"SEH",,,,,,Fa171Legenda())  
	
Endif
SetKey( VK_F12 , Nil )
Return(.T.)

/*/

Ŀ
Funo    A171Altera Autor  Eduardo Riera          Data  28.03.98 
Ĵ
Descrio  Programa de exclusao de Aplicacoes/Resgates                
Ĵ
Sintaxe    A171Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
user Function A171Altera(cAlias,nReg,nOpc)

Local lPanelFin := IsPanelFin()
//Ŀ
// Verifica se data do movimento no  menor que data limite de 
// movimentacao no financeiro e se nao houve resgate.           
//
If ( DtMovFin() .And. SEH->EH_SALDO != 0 )
	//Ŀ
	// Inicializa a geraao de lancamentos do SIGAPCO      
	//
	PcoIniLan("000008")		
	If lPanelFin
		dbSelectArea("SE5")		
		RegToMemory(cAlias,.T.,,,FunName())                                       		                                   
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()
		aDim := DLGinPANEL(oPanelDados)
		Altera := .T.			
  		nOpca := AxAltera(cAlias,nReg,nOpc,,,,,"Fa171TudOk(nOpc)","Fa171Alt",,,,,,,,.T.,oPanelDados,aDim,FinWindow)		
	Else
	   	AxAltera(cAlias,nReg,nOpc,,,,,"Fa171TudOk(nOpc)","Fa171Alt")	 
	Endif	  		
	//Ŀ
	// Inicializa a geraao de lancamentos do SIGAPCO      
	//
	PcoFinLan("000008")
	PcoFreeBlq("000008")
EndIf
Return(.T.)


/*/

Ŀ
Funo     Fa171Alt  Autor  Edson Maricate         Data  22.07.05 
Ĵ
Descrio  Funcao de complemento de gravao /Resgates                
Ĵ
Sintaxe    A171Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
STATIC Function Fa171Alt()
Local aArea	:= GetArea()

//Ŀ
// Gera os lancamentos do SIGAPCO                      
//
PcoDetLan("000008","01","XFINA171")

RestArea(aArea)
Return

/*/

Ŀ
Funo    A171Exclui Autor  Eduardo Riera          Data  28.03.98 
Ĵ
Descrio  Programa de exclusao de Aplicacoes/Resgates                
Ĵ
Sintaxe    A171Exclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
STATIC Function A171Exclui(cAlias,nReg,nOpc)
LOCAL oDlg
LOCAL nOpca      	:= 1
LOCAL cPadrao    	:= "581"
Local lDigita    	:= If(MV_PAR01==1,.T.,.F.)
Local nHdlPrv    	:= 0
LOCAL lPadrao    	:= VerPadrao(cPadrao)
LOCAL bCampo     	:= {|x| FieldName(x)}
LOCAL nTotal     	:= 0
LOCAL cArquivo   	:= ""
LOCAL lContabil  	:= .F.
LOCAL cHistorico 	:= ""
Local nCntFor 		:= 0   
Local lPanelFin 	:= IsPanelFin()
Local aFlagCTB		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local lAtuSldNat := .T.

Local lFA171Bco		:= ExistBlock("FA171BCO")
Local lMovBco		:= .T.
Local lAplCota		:= (SEH->EH_TIPO $ GetMv("MV_APLCAL4"))
Local lTemResgate	:= .T.

Local oModelMov := Nil //Model de Movimento Bancrio
Local oSubFK5
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local cCamposE5 := ""
Local nValor := 0 
Local nE5Recno := 0
Local cTpDoc := ""
Local lSEHBase   := SEH->(ColumnPos("EH_BASEDES")) > 0
Local cSinal	:= ""

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aTELA[0][0],aGETS[0] 

//Ŀ
// Verifica se houve resgate por cotas ou valor                 
//
If lAplCota
	lTemResgate := SEH->EH_SLDCOTA <> SEH->EH_QUOTAS
	If lTemResgate .And. Empty( SEH->EH_SLDCOTA ) .And. SEH->EH_SALDO > 0
		lTemResgate := SEH->EH_SALDO <> SEH->EH_QUOTAS
	EndIf	
Else
	lTemResgate := Round(SEH->EH_SALDO, TamSx3('EH_VALOR')[2]) <> SEH->EH_VALOR
EndIf

// Verifica se emprestimo teve algum valor de entrada
If SEH->EH_SALDO == SEH->EH_FINANC .And. !Empty(SEH->EH_ENTRADA)
	lTemResgate := .F.
EndIf

//Ŀ
// Verifica se data do movimento no  menor que data limite de 
// movimentacao no financeiro e se nao houve resgate.           
//
If	( !lTemResgate .And. Empty(SEH->EH_ULTAPR) ) .And. ;
	!CCBLOCKED(SEH->EH_BANCO,SEH->EH_AGENCIA,SEH->EH_CONTA) //Verifica bloqueio de conta corrente
	If !DtMovFin(,,IIF(SEH->EH_APLEMP=="APL","1","2"))
		Return
	EndIf 
	dbSelectArea(cAlias)
	If !SoftLock( "SEH" )
		Return
	EndIf
	dbSelectArea( cAlias )
	For nCntFor := 1 TO FCount()
		M->&(EVAL(bCampo,nCntFor)) := FieldGet(nCntFor)
	NEXT nCntFor
                  
	If lPanelFin  //Chamado pelo Painel Financeiro								
		RegToMemory(cAlias,.T.,,,FunName())                                       
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()		
		aDim := DLGinPANEL(oPanelDados)		
		nOpca := AxVisual(cAlias,nReg,nOpc,,,,,,,,.T.,,.T.,.T.,aDim)			
	Else
		nOpca := AxVisual(cAlias,nReg,nOpc,,,,,,,,,,,)
	Endif

	dbSelectArea(cAlias)

	If ( nOpca == 1 )
		SA6->(DBSetOrder(1))
		SA6->(MsSeek(xFilial("SA6")+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA))
	
		If ( SubStr(SEH->EH_LA,1,1) == "S" )
			lContabil := .T.
		EndIf
		If ( SEH->EH_APLEMP == "APL" )
			cHistorico := STR0014+" "+SEH->EH_TIPO //"Estorno de Aplicacao"
		Else
			cHistorico := STR0015+" "+SEH->EH_TIPO //"Estorno de Emprestimo"
		EndIf
		//Ŀ
		// Inicializa a geraao de lancamentos do SIGAPCO      
		//
		PcoIniLan("000008")
		//Ŀ
		// Inicio do bloco protegido via TTS          
		//
		If lFA171Bco
			//Ŀ
			//Ponto de entrada que indica se deve movimentar ou nao banco
			//
			lMovBco := ExecBlock("FA171Bco", .F., .F.,{nOpc} )
			If Valtype(lMovBco) <> "L"
				lMovBco := .T.
			EndIf
		EndIf
		
		Begin Transaction
		
			FCExcluiE2(SEH->EH_NUMERO,nOpc)
			
			If lMovBco				
				
				//Pega o registro da SE5 correspondente ao movimento da aplicao ou emprestimo posicionado
				cTpDoc := Iif( SEH->EH_APLEMP=="EMP", "EP", "AP" )				
				nE5Recno := FN171SE5( cTpDoc )
				If nE5Recno > 0 
					SE5->( dbGoto( nE5Recno ) ) 
				Else
					lRet := .F.
				Endif
				
				If lRet
				
					//Ŀ
					// Estorna Movimento Bancario                 
					//
					cCamposE5 += "{"		
					cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
					cCamposE5 += "}"
					
					oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento 
					oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
					oModelMov:Activate()
					oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou no
					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que sero gravados indepentes de FK5 
					oModelMov:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a incluso no ser feita com um novo nmero de processo
					
					//Dados do Processo
					oSubFKA := oModelMov:GetModel("FKADETAIL")
					oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
					oSubFKA:SetValue( "FKA_TABORI", "FK5" )
					
					//Informacoes do movimento
					oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
					nValor := SEH->EH_VLCRUZ
					oSubFK5:SetValue( "FK5_DATA", dDataBase )
					oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
					oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
					oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )				
					oSubFK5:SetValue( "FK5_VALOR", nValor )
					oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nValor, 1, SEH->EH_MOEDA ) )				
					oSubFK5:SetValue( "FK5_RECPAG", If(SEH->EH_APLEMP=="EMP","P","R") )
					oSubFK5:SetValue( "FK5_TPDOC", cTpDoc )
					oSubFK5:SetValue( "FK5_HISTOR", cHistorico )				
					oSubFK5:SetValue( "FK5_DTDISP", dDataBase )		
					oSubFK5:SetValue( "FK5_MOEDA", PADL(SEH->EH_MOEDA,TamSX3("CTO_MOEDA")[1],"0") )			
					oSubFK5:SetValue( "FK5_FILORI", SEH->EH_FILIAL )
					oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
					oSubFK5:SetValue( "FK5_ORIGEM", FunName() )				
					If lUsaFlag .and. ( MV_PAR02 == 1 )
						oSubFK5:SetValue( "FK5_LA", "S" )
					Endif
					If ( SEH->EH_APLEMP == "EMP" )
						oSubFK5:SetValue( "FK5_NATURE", &(GetMv("MV_NATEMP")) )
					Else
						oSubFK5:SetValue( "FK5_NATURE", &(GetMv("MV_NATAPLI")) )
					Endif																
					
					If oModelMov:VldData()		
						oModelMov:CommitData()
					    oModelMov:DeActivate()
					Else
						lRet := .F.
						cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					    cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
					    
					    Help( ,,"MF171EXC",,cLog, 1, 0 )	            
					Endif
					
					If lRet
						AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,;
							        IIf(SE5->E5_RECPAG == "R", "+", "-") )
						
						/*
						 * Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
						 */
						If lAtuSldNat
							AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", If(SEH->EH_APLEMP=="EMP","R","P"), SEH->EH_VLCRUZ, 0, "-",,FunName(),"SE5", SE5->(Recno()),0)
						EndIf
					Endif
					
				Endif
				
				If  !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
					cNumero := SEH->EH_NUMERO 
					MsgRun( STR0045,, { || FCGrvE5(cNumero,.T.) }  ) //"Aguarde, gravando as despesas do contrato..."
				EndIf
			EndIf
			
			If lRet
				//Ŀ
				//Lancamento Contabil                                            
				//
				IF ( lPadrao .And. MV_PAR02 == 1 .And. lContabil )
					//Ŀ
					// Inicializa Lancamento Contabil                                   
					//
					nHdlPrv := HeadProva( cLote, "XFINA171" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
				
					//Ŀ
					// Prepara Lancamento Contabil                                      
					//
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
						aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv, cPadrao, "XFINA171" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/,;
						                   /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/,;
						                   @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
	
					//Ŀ
					// Efetiva Lanamento Contabil                                      
					//
					RodaProva( nHdlPrv, nTotal )
					
					cA100Incl( cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, lDigita, .F. /*lAglut*/, /*cOnLine*/, /*dData*/,;
						         /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/ )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
				EndIf

				If ExistBlock("F171EXCL")
					Execblock("F171EXCL",.F.,.F.)
				Endif
			
				//Ŀ
				// Gera os lancamentos do SIGAPCO                      
				//
				dbSelectArea("SEH")            
				PcoDetLan('000008',"01","XFINA171",.T.)
				RecLock("SEH",.F.)
				dbDelete()
				
			Endif
			
			//Ŀ
			// Final  do bloco protegido via TTS          
			//
		End Transaction
	
		//Ŀ
		// Finaliza os lancamentos do SIGAPCO  
		//
		PcoFinLan("000008")
	EndIf
	dbSelectArea( cAlias )
	MsUnLock()
Else
	Help(" ",,"A171DELETA")
EndIf
dbSelectArea( cAlias )
Return(.T.)

/*/

Ŀ
Funo    A171Inclui Autor  Eduardo Riera          Data  28.03.98 
Ĵ
Descrio  Programa de Incluisao de Aplicacoes e Emprestimo           
Ĵ
Sintaxe    A171Inclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
USER Function A171Inclui(cAlias,nReg,nOpc)

Local lPanelFin  := If (FindFunction("IsPanelFin"),IsPanelFin(),.F.)
Local nOpca	     :=	0
Local cTitulo    := ""
Local cPrograma  := 'XFINA171'
Local nOperation := MODEL_OPERATION_UPDATE
Local lRet		 := .F.
Local nRet       := 0
Local lSEHBase   := SEH->(ColumnPos("EH_BASEDES")) > 0
Local aEnableButtons := {{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.T.,Nil},{.T.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil}} //"Confirmar"###"Fechar"

//Ŀ
// Inicializa a geraao de lancamentos do SIGAPCO      
//
PcoIniLan("000008")
//Ŀ
// Inicio do bloco protegido via TTS                            
//
//Begin Transaction
dbSelectArea( cAlias )

BEGIN TRANSACTION

If lPanelFin
	dbSelectArea("SE5")
	RegToMemory("SE5",.T.,,,FunName())                                       
	oPanelDados := FinWindow:GetVisPanel()
	oPanelDados:FreeChildren()
	aDim := DLGinPANEL(oPanelDados)
	Inclui := .T.	
	If DtMovFin()
		nOpca := AxInclui(cAlias,nReg,nOpc,,,,"Fa171TudOk(nOpc)",,'Fa171Grv("'+cAlias+'")',,,,,,,.T.,oPanelDados,aDim,FinWindow)
	EndIf	
Else
	If DtMovFin()
		nOpca := AxInclui(cAlias,nReg,nOpc, , , ,"Fa171TudOk(nOpc)",,'Fa171Grv("'+cAlias+'")')
	EndIf
Endif	
//Ŀ
// Finaliza os lancamentos do SIGAPCO e libera os bloqueios        
//

PcoFinLan("000008")
PcoFreeBlq("000008")

//Apresenta uma tela demonstrando os valores do contrato bem como o valor que dever ser pago em cada parcela
If SEH->EH_TIPO == 'EMP' .And. !Empty(SEH->EH_AMORTIZ) .And. nOpca == 1
	cNumero := SEH->EH_NUMERO
	
	//Carrega as parcelas no arquivo temporario
	MsgRun( STR0043,, { || lRet := FC171Par(cNumero,nOpc) }  ) //"Aguarde, realizando o calculo das parcelas...
	If lRet
		// Chama a view da tabela SEH
		nRet := FWExecView(cTitulo , cPrograma, nOperation, /*oDlg*/, {|| .T. } ,{ || FCAtuOK()}, /*nPercReducao*/, aEnableButtons, /*bCancel*/ , /*cOperatId*/, /*cToolBar*/, /*oModel*/ )
		Inclui := .T.
		Altera := .F.	
		If (nRet == 0)
			// Chama funo para gravao do Contas a Pagar (SE2)
			Processa({||U_FCGrvE2('TRB',cNumero)},STR0044) //"Aguarde, gravando as parcelas no contas a pagar..."
			//Grava os valores das despesas
			If  !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
				MsgRun( STR0045,, { || FCGrvE5(cNumero,.F.) }  ) //"Aguarde, gravando as despesas do contrato..."
			EndIf
		ElseIf (nRet == 1) // Cancela incluso de emprstimo
			// Fecha o arquivo temporario
			If(_oXFINA171 <> NIL)
				_oXFINA171:Delete()
				_oXFINA171 := NIL
			EndIf
			
			//apaga registros referentes as parcelas
			RecLock("SEH",.F.)
			SEH->EH_PRAZO   := 0
			SEH->EH_AMORTIZ := ""
			SEH->EH_GERPARC := ""
			SEH->( MsUnlock() )

//			MsgInfo(STR0054,STR0017)// Emprestimo Financeiro //"Processo cancelado. O emprestimo ser gravado sem a gerao de parcelas."
			MsgInfo("Proceso cancelado",STR0017)// Emprestimo Financeiro //"Processo cancelado. O emprestimo ser gravado sem a gerao de parcelas."
		EndIf
	EndIf
EndIf

END TRANSACTION

Return
/*/

Ŀ
Funo    A171Grv    Autor  Bruno Sobieski         Data  28.03.98 
Ĵ
Descrio  Programa de gravacao da aplicacao                          
Ĵ
Sintaxe    A171Grv(cAlias)                                            
Ĵ
Parametros cAlias= Alias do arquivo                                   
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
STATIC Function Fa171Grv(cAlias)
	Local cPadrao    :="580"
	Local lDigita    := If(MV_PAR01==1,.T.,.F.)
	Local nHdlPrv    := 0
	Local lPadrao    := VerPadrao(cPadrao)
	Local nTotal     := 0
	Local cArquivo   := ""
	Local cHistorico := ""
	Local lFin171    :=ExistBlock("FIN171")
	Local nBcoMoeda  := 1   
	Local aFlagCTB   := {}
	Local lUsaFlag   := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
	Local lAtuSldNat := .T.
	Local lFA171Bco  := ExistBlock("FA171BCO")
	Local lMovBco    := .T.
	Local oModelMov := FWLoadModel("FINM030") //Model de Movimento Bancrio
	Local oSubFK5
	Local oSubFKA
	Local cLog := ""
	Local lRet := .T.
	Local cCamposE5 := ""
	Local nValor := 0

	If ( SEH->EH_APLEMP=="APL" )
		cHistorico := STR0016+" "+SEH->EH_TIPO //"Aplicacao Financeira"
	Else
		cHistorico := STR0017+" "+SEH->EH_TIPO //"Emprestimo Financeiro"
	EndIf
	dbSelectArea('SA6')
	dbSetOrder(1)
	If dbSeek(xFilial()+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA)
		nBcoMoeda := Max(SA6->A6_MOEDA,1)
	EndIf	

	dbSelectArea("SEH")
	RecLock("SEH",.F.)
	If !lUsaFlag .and. ( mv_par02 == 1 )
		SEH->EH_LA := "S"
	ElseIf ( lPadrao .and. MV_PAR02 == 1 )
		aAdd( aFlagCTB, {"EH_LA", "S", "SEH", SEH->( Recno() ), 0, 0, 0} )
	Endif
	SEH->EH_STATUS := If( SEH->EH_SALDO < 0.01, "B", "A" )
	If lFA171Bco
		//Ŀ
		//Ponto de entrada que indica se deve movimentar ou nao banco
		//
	   lMovBco := ExecBlock("FA171Bco", .F., .F., )
		If Valtype(lMovBco) <> "L"
			lMovBco := .T.
		EndIf
	EndIf
	If lMovBco
		//Ŀ
		//Gera movimentacao bancaria - Aplicacao                            
		//
		
		cCamposE5 += "{"		
		cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
		cCamposE5 += "}"
		
		oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelMov:Activate()
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou no
		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que sero gravados indepentes de FK5 
		oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a incluso ser feita com um novo nmero de processo
		
		//Dados do Processo
		oSubFKA := oModelMov:GetModel("FKADETAIL")
		oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
		oSubFKA:SetValue( "FKA_TABORI", "FK5" )
		
		//Informacoes do movimento
		oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
		nValor := If( cPaisLoc=="BRA", SEH->EH_VLCRUZ, xMoeda( SEH->EH_VALOR,SEH->EH_MOEDA,nBcoMoeda,,,aTxMoedas[SEH->EH_MOEDA][2],aTxMoedas[nBcoMoeda][2] ) )
		oSubFK5:SetValue( "FK5_DATA", SEH->EH_DATA )
		oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
		oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
		oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )
		oSubFK5:SetValue( "FK5_VALOR", nValor )
		oSubFK5:SetValue( "FK5_VLMOE2", If( cPaisLoc=="BRA", xMoeda( nValor,1,SEH->EH_MOEDA ), SEH->EH_VALOR * aTxMoedas[SEH->EH_MOEDA][2] ) )
		oSubFK5:SetValue( "FK5_RECPAG", Iif(SEH->EH_APLEMP=="EMP","R","P") )
		oSubFK5:SetValue( "FK5_TPDOC", Iif(SEH->EH_APLEMP=="EMP","EP","AP") )
		oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
		oSubFK5:SetValue( "FK5_DTDISP", SEH->EH_DATA )		
		oSubFK5:SetValue( "FK5_MOEDA", PADL(nBcoMoeda,TamSX3("CTO_MOEDA")[1],"0") )			
		oSubFK5:SetValue( "FK5_FILORI", SEH->EH_FILIAL )
		oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
		oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )
		oSubFK5:SetValue( "FK5_ORIGEM", FunName() )
		If ! lUsaFlag .and. ( mv_par02 == 1 )
			oSubFK5:SetValue( "FK5_LA", "S" )
		Endif																			
		
		If oModelMov:VldData()		
			oModelMov:CommitData()
		    oModelMov:DeActivate()
		Else
			lRet := .F.
			cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
		    
		    Help( ,,"MF171GRV",,cLog, 1, 0 )	            
		Endif
		
		AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,;
			        Iif( SE5->E5_RECPAG=="R", "+", "-") )
		
		If lAtuSldNat
			/*
			 * Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
			 */
			AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", If(SEH->EH_APLEMP=="EMP","R","P"), SEH->EH_VLCRUZ, 0, "+",,FunName(),"SE5", SE5->(Recno()),0)
		EndIf
	EndIf
	//Ŀ
	//Verifica se a natureza esta cadastrada. Se nao, cria.             
	//
	Fa171AtuNat(SE5->E5_NATUREZ,SEH->EH_APLEMP,"XFINA171")

	If UsaSeqCor()
		aDiario := {{"SEH",SEH->(Recno()), SEH->EH_DIACTB, "EH_NODIA","EH_DIACTB"}}
	Else
		aDiario := {} 
	EndIf
	
	//Ŀ
	//Lancamento Contabil                                               
	//
	If ( lPadrao .and. MV_PAR02 == 1 )
		//Ŀ
		// Inicializa Lancamento Contabil                                   
		//
			nHdlPrv := HeadProva( cLote,;
			                      "XFINA171" /*cPrograma*/,;
			                      Substr( cUsuario, 7, 6 ),;
			                      @cArquivo )

		//Ŀ
		// Prepara Lancamento Contabil                                      
		//
			If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
				aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
			Endif
			nTotal += DetProva( nHdlPrv,;
			                    cPadrao,;
			                    "XFINA171" /*cPrograma*/,;
			                    cLote,;
			                    /*nLinha*/,;
			                    /*lExecuta*/,;
			                    /*cCriterio*/,;
			                    /*lRateio*/,;
			                    /*cChaveBusca*/,;
			                    /*aCT5*/,;
			                    /*lPosiciona*/,;
			                    @aFlagCTB,;
			                    /*aTabRecOri*/,;
			                    /*aDadosProva*/ )

		//Ŀ
		// Efetiva Lanamento Contabil                                      
		//
			RodaProva( nHdlPrv,;
			           nTotal)

			cA100Incl( cArquivo,;
			           nHdlPrv,;
			           3 /*nOpcx*/,;
			           cLote,;
			           lDigita,;
			           .F. /*lAglut*/,;
			           /*cOnLine*/,;
			           /*dData*/,;
			           /*dReproc*/,;
			           @aFlagCTB,;
			           /*aDadosProva*/,;
			           aDiario )
			aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	EndIf                   

	//Ŀ
	// Gera os lancamentos do SIGAPCO                      
	//
	PcoDetLan("000008","01","XFINA171")
	DbSelectArea( cAlias )

	If lFin171 
		Execblock("FIN171",.F.,.F.)
	Endif

Return(.T.)

/*/


Ŀ
Funo    Fa171Perg  Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio Ativa funcao pergunte                                       
Ĵ
Sintaxe   Fa171Perg()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      Generico                                                    
ٱ


/*/
Static Function Fa171Perg()

pergunte("AFI171",.T.)

Return(.T.)

/*/


Ŀ
Funo    Fa171TudOk Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio  Validacao da Inclusao da Aplicacao ou Emprestimo           
Ĵ
Sintaxe   Fa171TudOk()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso      XFINA171                                                     
ٱ


/*/
STATIC Function Fa171TudOk(nOpc)
LOCAL aArea    := GetArea()
LOCAL lRetorna := .F. 
Local lF171OK := ExistBlock("F171OK")

If UsaSeqCor()
	Private cCodDiario := SEH->EH_DIACTB
Endif

If ( M->EH_APLEMP=="APL" )
	//Ŀ
	// Validacao das Aplicacoes baseadas em contratos               
	//
	If M->EH_TIPO $(GetMv("MV_APLCAL4"))
		If !Empty(M->EH_QUOTAS) .And. !Empty(M->EH_CONTRAT)
			lRetorna := .T.
		Endif	
	Else
		//Ŀ
		// Validacao das Aplicacoes baseadas em Taxa Pr-Fixada ou      
		// correcao monetaria.                                          
		//
		If ( !Empty(M->EH_VALOR) )
			lRetorna := .T.
		EndIf
	EndIf
Else
	If ( M->EH_TAXA >= 0 .And. M->EH_VALOR != 0 .And.;
		M->EH_SALDO != 0 .And. M->EH_VLCRUZ != 0 )
		lRetorna := .T.
	EndIf
EndIf
If ( lRetorna )
	lRetorna := ExistCpo("SA6",M->EH_BANCO+M->EH_AGENCIA+M->EH_CONTA)
EndIf
If ( lRetorna .And. M->EH_VLCRUZ==0 )
	lRetorna := .F.
EndIf
If ( !lRetorna )
	Help(" ",1,"FA171TUDOK")
ElseIf CCBLOCKED(M->EH_BANCO,M->EH_AGENCIA,M->EH_CONTA) //Verifica bloqueio de conta corrente
	lRetorna := .F.
EndIf                                          
If lRetorna
	lRetorna	:=	PcoVldLan('000008','01','XFINA171')	
Endif 

If UsaSeqCor()
	If !CTBvldDiario( M->EH_DIACTB, dDataBase )
		lRetorna := .F.
	EndIf
Endif

If lRetorna .And. M->EH_APLEMP == "EMP"
	If (M->EH_GERPARC == "1" .And. Empty(M->EH_AMORTIZ))
		lRetorna := .F.
		Aviso(STR0017,STR0052) // Emprestimo Financeiro //Para o modelo Emprstimo optante por gerao de parcelas, deve-se utilizar uma tabela de Amortizao!"
	EndIf
EndIf

If lRetorna .And. M->EH_APLEMP == "EMP"
	If (!Empty(M->EH_AMORTIZ) .And. M->EH_GERPARC == "1" .And. M->EH_PRAZO == 0 .And. M->EH_VLAMORP == 0)
		lRetorna := .F.
		MsgInfo(STR0017,STR0053)// Emprestimo Financeiro //"Para o modelo Emprstimo optante por gerao de parcelas vinculadas a uma tabela de Amortizao, o Prazo ou Valor Amortizao/Parcela deve ser maior que zero !"
	EndIf
EndIf

RestArea(aArea)

If lF171OK .And. lRetorna
	lRetorna := Execblock("F171OK",.F.,.F.)
Endif 

If ( M->EH_APLEMP=="APL" )
	If !CtbValiDt(,M->EH_DATA,,,,{"FIN001"},)
		lRetorna := .F.
	Endif
Else
	If !CtbValiDt(,M->EH_DATA,,,,{"FIN002"},)
		lRetorna := .F.
	Endif
Endif

// No permite alterar as parcelas j gravadas no contas a pagar
If nOpc == 4
	dbSelectArea("SE2")
	If SE2->(dbseek(xFilial("SE2")+"EMP"+M->EH_NUMERO)) 
		MsgInfo(STR0019,STR0017) //"No ser alterada as parcelas j gravadas no contas a pagar!" // "Emprestimo Financeiro"
	EndIf
EndIf

Return(lRetorna)

/*/


Ŀ
Funo    fa171Opera Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio Verifica a Operacao efetuada                                
Ĵ
Sintaxe   Fa171Oper()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      XFINA171                                                     
ٱ


/*/
STATIC Function Fa171OPera()
LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL lRetorna := .T.

dbSelectArea("SX5")
dbSetOrder(1)
dbSeek(xFilial()+"11"+M->EH_TIPO)
IF ( !Found() )
	Help(" ",1,"NOTIPOAPL")
	lRetorna := .F.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return( lRetorna )

/*/

Ŀ
Funo    FA171Nat   Autor  Eduardo Riera                30/03/98 
Ĵ
Descrio Inicializador Padrao da Natureza Finaceira                  
Ĵ
Sintaxe   Fa171Nat()                                                  
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
static Function Fa171Nat()

If ( M->EH_APLEMP == "APL" )
	M->EH_NATUREZ := PadR(&(GetMv("MV_NATAPLI")),TamSX3("EH_NATUREZ")[1])
Else
	M->EH_NATUREZ := PadR(&(GetMv("MV_NATEMP")),TamSX3("EH_NATUREZ")[1])
EndIf
Fa171AtuNat(M->EH_NATUREZ,M->EH_APLEMP,"XFINA171")

Return .T.

/*/


Ŀ
Funo    Fa171AtuNa Autor  Eduardo Riera          Data  31/03/98 
Ĵ
Descrio  Verifica se a Natureza foi cadastrada, se nao, cria.       
Ĵ
Sintaxe    XFINA171()                                                  
Ĵ
 Uso       SIGAFIN                                                    
ٱ


/*/
static Function Fa171AtuNat(cNat,cTipo,cFonte)

Local cAlias:= Alias()

dbSelectArea("SED")
dbSetOrder(1)
If !dbSeek(xFilial("SED")+cNat) .And. !Empty(cNat)
	RecLock("SED",.T.)
	Replace ED_FILIAL    With xFilial("SED")
	Replace ED_CODIGO    With cNat
	If cTipo == "EMP"
		If cFonte=="XFINA171"
			Replace ED_DESCRIC   With STR0010  //"NATUREZA EMPRESTIMOS"
		Else
			Replace ED_DESCRIC   With STR0012  //"NATUREZA PGT.EMPRESTIMOS"
		Endif
	Else
		If cFonte=="XFINA171"
			Replace ED_DESCRIC   With STR0011  //"NATUREZA APLICACOES"
		Else
			Replace ED_DESCRIC   With STR0013  //"NATUREZA RESG.APLICACOES"
		Endif
	EndIF
	Replace ED_CALCIRF   With "N"
	Replace ED_CALCISS   With "N"
	Replace ED_PERCIRF   With 0
	Replace ED_TIPO		 With "2"
	MsUnlock()
EndIf
dbSelectArea(cAlias)
Return 

/*/


Ŀ
Funo    Fa171Cdi   Autor  Andr Luiz B. Silva  Data  14/02/2013 
Ĵ
Descrio "	Validao de campos quando EH_CLSIOF == 1                 
Ĵ
Sintaxe   Fa171Cdi ()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      XFINA171                                                     
ٱ


/*/

static Function Fa171Cdi()

Local lRetorna := .T.  
Local lClsIof  := .T.

If lClsIof
	If (INCLUI .AND. ALLTRIM(M->EH_TIPO) == 'CDI' .And. ALLTRIM(M->EH_CLSIOF) == '1' )
		lRetorna := .F. 
	EndIf
Endif

Return( lRetorna )

/*/


Ŀ
Funo    fa171Apl   Autor  Eduardo Riera          Data  12/04/98 
Ĵ
Descrio Valicacao dos campos pertencentes a aplicacao               
Ĵ
Sintaxe   Fa171Apl ()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      XFINA171                                                     
ٱ


/*/
static Function Fa171Apl()
LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL lRetorna := .F.

If ( INCLUI .And. M->EH_APLEMP=="APL" )
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return( lRetorna )

/*/


Ŀ
Funo    fa171Emp   Autor  Eduardo Riera          Data  12/04/98 
Ĵ
Descrio Valicacao dos campos pertencentes ao emprestimo             
Ĵ
Sintaxe   Fa171Emp ()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      XFINA171                                                     
ٱ


/*/
static Function Fa171Emp()
LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL lRetorna := .F.

If ( INCLUI .And. M->EH_APLEMP=="EMP" )
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return( lRetorna )

/*/


Ŀ
Funo    Fa171AtuVl Autor  Alexandre Silva        Data  10/01/02 
Ĵ
Descrio Faz a conversao do valor para Multi-Moedas,baseado no array 
aTxMoeda, que contem o valor da moeda na contacao atual, ou digitada   
pelo usuario.                                                          
Ĵ
Sintaxe   Fa171Atuvl()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso      XFINA171                                                     
ٱ


/*/
static Function Fa171AtuVl(lValid)
Local uRetorno  := 0

DEFAULT lValid := .F. // Sera utilizada para validar ou para obter o valor da operacao ?

	If M->EH_MOEDA >= 1 .And. M->EH_MOEDA <= MoedFin() 
		If lValid
			uRetorno := .T.
		Else	
			uRetorno := M->EH_VALOR * aTxMoedas[M->EH_MOEDA][2]
		Endif	
	Else
		Help( " ",1,"SEMMOEDA" )
		If lValid
			uRetorno := .F.
		Else	
			uRetorno := M->EH_VALOR
		Endif	
	EndIf	

Return uRetorno 


/*/

Ŀ
Funo    Fa181Legenda Autor  Mauricio Pequin Jr.  Data  05.05.08 
Ĵ
Descrio  Cria uma janela contendo a legenda da mBrowse ou retorna a 
           para o BROWSE                                              
Ĵ
 Uso       Fina181                                                    
ٱ


/*/
static Function Fa171Legenda(nReg)

Local aLegenda := {{"BR_VERDE", 	"Aplicao com Saldo" },;	//"Aplicao com Saldo"
						 {"BR_VERMELHO","Aplicao Resgatada" }}	//"Aplicao Resgatada"   
Local uRetorno := .T.

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	Aadd(uRetorno, { 'EH_SALDO <= 0'	, aLegenda[2][1] } )
	Aadd(uRetorno, { 'EH_SALDO > 0'	, aLegenda[1][1] } )
Else
	BrwLegenda(cCadastro, "Legenda", aLegenda)
Endif

Return uRetorno
/*/


Ŀ
Programa  MenuDef    Autor  Ana Paula N. Silva      Data 23/11/06 
Ĵ
Descrio  Utilizacao de menu Funcional                               
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados     
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()
Local aRotina := {}
	
aAdd(aRotina,{STR0001	, "AxPesqui" 	, 0, 1,,.F.})	//Pesquisar
aAdd(aRotina,{STR0002	, "AxVisual"	, 0, 2})		//"Visualizar"
aAdd(aRotina,{STR0003	, "U_A171Inclui"	, 0, 3})		//"Incluir"
aAdd(aRotina,{STR0004	, "A171Altera"	, 0, 4})		//"Alterar"
aAdd(aRotina,{STR0005	, "A171Exclui"	, 0, 5})		//"Excluir"
aAdd(aRotina,{STR0041   , "FC171_V"		, 0, 8})		//"Visualizar Parcelas"
aAdd(aRotina,{STR0042   , "FC171Imp"	, 0, 2})		//"Imprimir Parcelas"

//S incluo a opo para cadastrar a taxa dos ndices caso exista a nova tabela FO3
If TableInDic( 'FO3' )
	aAdd(aRotina,{"STR0066"	, "Fa171Idx"	, 0, 2,,.F.})	//"Taxas dos ndices"
EndIf

aAdd(aRotina,{STR0018	, "Fa171Legenda", 0, 2,,.F.})	//"Legenda"
	
Return(aRotina)

/*/

Ŀ
Funo    XFinA171T    Autor  Marcelo Celi Marques  Data  04.04.08 
Ĵ
Descrio  Chamada semi-automatica utilizado pelo gestor financeiro   
Ĵ
 Uso       XFINA171                                                    
ٱ


/*/
static Function XFinA171T(aParam)
	cRotinaExec := "XFINA171"
	ReCreateBrow("SEH",FinWindow)      		
	XFinA171(aParam[1])
	ReCreateBrow("SEH",FinWindow)      	

	dbSelectArea("SEH")
	
	INCLUI := .F.
	ALTERA := .F.

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} FN171SE5
Funo para encontrar o registro de SE5 correspondente ao movimento
da aplicao ou emprstimo posicionado (SEH) 

@param cTpDoc, Tipo Doc que ser considerado na busca ("AP" ou "EP")
@return nRecno, identificao do registro na SE5
@author Pedro Alencar
@since 08/05/2014
@version P12
/*/
//-------------------------------------------------------------------
Static Function FN171SE5 (cTpDoc)
	Local nRecno := 0
	Local cQuery := ""
	Local cDocumen := ""
	Local cAliasTMP := ""
	Default cTpDoc := "AP"
	
	//Concatena o nmero e a reviso da aplicao (SEH) para buscar na SE5 (E5_DOCUMEN)
	cDocumen := SEH->EH_NUMERO + SEH->EH_REVISAO
	
	cQuery := "SELECT R_E_C_N_O_ "
	cQuery += "FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE SE5.E5_DOCUMEN = '" + cDocumen + "' "
	cQuery += "AND SE5.E5_TIPODOC = '" + cTpDoc  + "' " 
	cQuery += "AND SE5.E5_DATA = '" + DTOS(SEH->EH_DATA) + "'"  
	
	cQuery := ChangeQuery(cQuery)				
	cAliasTMP := GetNextAlias()
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasTMP, .T., .F. )
	
	//Pega o recno da SE5 referente a aplicao
	( cAliasTMP )->( dbGoTop() )				
	nRecno := ( cAliasTMP )->R_E_C_N_O_
	
	(cAliasTMP)->( dbCloseArea() )
	FErase( cAliasTMP + GetDBExtension() )	
		
Return nRecno

//------------------------------------------------------------------------------------------
/* {Protheus.doc} ModelDef
Monta a tela demonstrando os valores do Contrato bem como o valor que dever ser pago
em cada parcela (ou amortizado a cada ms).
@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function ModelDef()

// Cria as estruturas a serem usadas no Modelo de Dados
Local oStruSEH  := FWFormStruct(1, 'SEH')
Local oStruFLY1 := MontaSCab()
Local oModel    

// Posiciona no arquivo correto
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

// Code block com as parcelas do financiamento/emprestimo
bLoad := {|oGridModel, lCopy| bLoadGrd}

// Cria o objeto do Modelo de Dados
//oModel := MPFormModel():New('XFINA171')
oModel := MPFormModel():New('XFINA171',/*preValid */,/*bPosValidacao*/,{ |oModel| XFINA171Commit( oModel ) }, /*bCancel*/ ) // Nahim Commit XFINA171

//oModel := MPFormModel():New( 'XFINA171', ,{ |oModel| FCTeste( oModel ) } )

// Adiciona ao modelo um componente de formulrio
oModel:AddFields( 'SEHMASTER', /*cOwner*/, oStruSEH )
	
//Adiciona ao modelo um componente de grid
oModel:AddGrid( 'FLYDETAIL', 'SEHMASTER', oStruFLY1,,,,,bLoad)

//Criao de relao entre as entidades do modelo (SetRelation)
oModel:SetRelation( 'FLYDETAIL', { { 'EH_FILIAL', 'xFilial( "SEH" )' }, { 'EH_NUMERO' , 'EH_NUMERO'  } } , SEH->( IndexKey( 1 ) )  )
	
// Adiciona a descrio do Modelo de Dados
oModel:SetDescription(STR0038) //"Detalhe do valor do contrato e suas parcelas"

// Adiciona a descrio dos Componentes do Modelo de Dados
oModel:GetModel( 'SEHMASTER' ):SetDescription(STR0039) //"Detalhe do Emprestimo/Financiamento"
oModel:GetModel( 'FLYDETAIL' ):SetDescription(STR0040) //"Projeo de valor das parcelas do contrato"

oModel:GetModel( 'FLYDETAIL' ):SetNoInsertLine( .T. )

//Define uma chave primaria (obrigatorio mesmo que vazia)	
oModel:SetPrimaryKey( {} )

Return oModel



// nahim adicionando commit 27/11/2019

static function XFINA171Commit(oModel)
Local oModelK    := FwModelActive()
local oModelGrid := nil
local nLin
oModelGrid := oModelK:GetModel( "FLYDETAIL" ) // obtener el modelo del grid
nTotLin := oModelGrid:Length( .F. ) // obtenes el TOTAL de lineas del grid
//alert("PASA")  //NAHIM
aCuotas := {}
SaveInter() // Salva as variaveis publicas
For nLin := 1 To nTotLin - 1  
		
	 oModelGrid:SetLine( nLin ) // le das el total
//	aAdd(aCuotas,{oModelGrid:GetValue("PARCELA" ),nAntValor, nAntJuros,NvECORRE,nAntAmorti ,oModelGrid:GetValue("PRESTACAO" ),oModelGrid:GetValue("DATA" ) })
	aAdd(aCuotas,{oModelGrid:GetValue("PARCELA" ),oModelGrid:GetValue("VALOR" ), oModelGrid:GetValue("JUROS" ),oModelGrid:GetValue("VCORRIGIDO" ),oModelGrid:GetValue("AMORTIZA" ),oModelGrid:GetValue("PRESTACAO" ),oModelGrid:GetValue("DATA" ) })
Next	
	
	
return .t.


// nahim cabio
static function linePostGrid()
Local oModelK    := FwModelActive()
local oModelGrid := nil
local nLin

aCuotas := {}
SaveInter() // Salva as variaveis publicas

oModelGrid := oModelK:GetModel( "FLYDETAIL" ) // obtener el modelo del grid
nTotLin := oModelGrid:Length( .F. ) // obtenes el TOTAL de lineas del grid
	 nInicial := 1
	 nTotTot := 0// valor total saldo capital
	 nAntJuros := 0// valor inters
	 nAntAmorti   := 0// valor amortizacin
     nAntValor := 0
	 nTotImpuest := 0
	 nTotalAmort := 0
For nLin := 1 To nTotLin - 1  

	 oModelGrid:SetLine( nLin ) // le das el total

		if nInicial <> nLin // si es que no es el primero
			oModelGrid:SetValue( "VALOR",nAntValor - nAntAmorti ) // calcula el valor de nuevo
		endif
			
			if nlin == 1 // PRIMERA CUOTA
				aCalculo := Fa171Calc(oModelGrid:GetValue("DATA" ), oModelGrid:GetValue("VALOR" ), .F.)
				nValJuros := Round(aCalculo[1][2],2)
				oModelGrid:SetValue( "JUROS",nValJuros)
			else
				aCalculo := Fa171Calc(oModelGrid:GetValue("DATA" ), oModelGrid:GetValue("VALOR" ), .F.)
				nValJuros := Round(aCalculo[1][2],2)
				oModelGrid:SetValue( "JUROS",nValJuros)
			endif
//			oModelGrid:SetValue( "JUROS",oModelGrid:GetValue("VALOR" ) * (M->EH_TAXA /100) / (360/M->EH_UINTDIA))
//			oModelGrid:SetValue( "JUROS",oModelGrid:GetValue("VALOR" ) * (M->EH_TAXA /100) / (365/M->EH_UINTDIA))
			
			/*if nLin == 1 // Primera Cuota
				aCalculo := Fa171Calc(M->EH_DATA, nValDeb, .F.)
				nValInteres := Round(aCalculo[1][2],2)
			else // es otra cuota
				
			endif*/

			oModelGrid:SetValue( "PRESTACAO", oModelGrid:GetValue("JUROS") + oModelGrid:GetValue("AMORTIZA" ) )    // modificas el VALOR
			oModelGrid:SetValue( "VCORRIGIDO", oModelGrid:GetValue("VALOR") + oModelGrid:GetValue("JUROS" ) )    // modificas el VALOR
				
	 nAntValor := oModelGrid:GetValue("VALOR" )// valor total saldo capital
	 nAntJuros := oModelGrid:GetValue("JUROS" ) // VALOR impuestos
	 nAntAmorti   := oModelGrid:GetValue("AMORTIZA" )// valor amortizacin
	 NvECORRE	:= oModelGrid:GetValue("VCORRIGIDO" )
	 nTotTot +=  oModelGrid:GetValue("PRESTACAO" )
	 nTotImpuest += nAntJuros
	 nTotalAmort += oModelGrid:GetValue("AMORTIZA" )
	aAdd(aCuotas,{oModelGrid:GetValue("PARCELA" ),nAntValor, nAntJuros,NvECORRE,nAntAmorti ,oModelGrid:GetValue("PRESTACAO" ),oModelGrid:GetValue("DATA" ) })
	 
	 
Next
	oModelGrid:SetLine( nLin ) // le das el total
	oModelGrid:SetValue( "JUROS",nTotImpuest)
	oModelGrid:SetValue( "PRESTACAO", nTotTot )    // modificas el VALOR
	oModelGrid:SetValue( "AMORTIZA", nTotalAmort )    // modificas el VALOR
	oModelGrid:SetLine( 1 ) // 
//FWModelActive( oModelBkp )
//	oModelK:DeActivate()
//	oModelK:Destroy()
//oView:Refresh() // haces un refresh a la VIEW
//RestInter() // Restaura as variavis publicas

return .T.

//------------------------------------------------------------------------------------------
/* {Protheus.doc} ViewDef
Visualiza a tela demonstrando os valores do Contrato

@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function ViewDef()

// Cria as estruturas a serem usadas na View
Local oStruSEH  := FWFormStruct(2, 'SEH')
Local oStruFLY1 := MontaSView()
Local cConsSEH  := "EH_VALOR;EH_ENTRADA;EH_FINANC;EH_PRAZO;EH_CARENCI;EH_AMORTIZ,EH_NUMERO;EH_NBANCO;EH_TAXA;EH_TXEFETI;EH_VLAMORP"
Local aStruSEH  := SEH->(DbStruct())
Local nAtual    := 0

// Interface de visualizao construda
Local oView  

//Percorre a estrutura da SEH para remover os campos que no iro aparecer na cabecalho
For nAtual := 1 To Len(aStruSEH)
	//Se o campo atual no estiver nos que forem considerados
	If ! Alltrim(aStruSEH[nAtual][01]) $ cConsSEH
		oStruSEH:RemoveField(aStruSEH[nAtual][01])
	EndIf
Next

// Cria o objeto de View
oView := FWFormView():New()

// Cria um objeto de Modelo de dados baseado no ModelDef do fonte informado
oModel := FWLoadModel( 'XFINA171' )

// Adiciona botes
oView:AddUserButton(STR0037, 'FORNECE', {|oView| FC171Fornece(oView) } )	//"Definir Fornecedor"

// Define qual Modelo de dados ser utilizado
oView:SetModel( oModel )
		
oView:AddUserButton("Recalculo", 'PROBAR', {|| linePostGrid() } )	//Recalcula la grid
// Adiciona no nosso View um controle do tipo formulrio (antiga Enchoice)
oView:AddField( 'VIEW_SEH', oStruSEH, 'SEHMASTER' )
	
//Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
oView:AddGrid( 'VIEW_FLY', oStruFLY1, 'FLYDETAIL' )
	
// Cria um "box" horizontal para receber cada elemento da view
oView:CreateHorizontalBox( 'SUPERIOR', 33 )
oView:CreateHorizontalBox( 'INFERIOR', 67 )
		
// Relaciona o identificador (ID) da View com o "box" para exibio
oView:SetOwnerView( 'VIEW_SEH', 'SUPERIOR' )
oView:SetOwnerView( 'VIEW_FLY', 'INFERIOR' )
	
// Liga a identificacao do componente
oView:EnableTitleView( 'VIEW_SEH' )
oView:EnableTitleView( 'VIEW_FLY' )

// Nao exibe a mensagem de atualizacao
oView:ShowUpdateMsg(.F.)		

Return oView


//------------------------------------------------------------------------------------------
/*/ {Protheus.doc} FC171Par
Realiza o calculo das parcelas para apresentacao em tela

@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
/*/
//------------------------------------------------------------------------------------------

Static Function FC171Par(cNumero,nOpc)

Local lRet		 := .T.
Local aCalculo := {}
Local dDataVenc:= STOD("")
Local dPrimVenc:= STOD("")
Local lPriParc := .T.
Local nParcela := 1
Local nI	   := 1	
Local nValAmor := 0
Local nValCorr := 0
Local nValDeb  := 0
Local nValJuros:= 0
Local nValPrest:= 0
Local nTotJuros:= 0
Local nTotPrest:= 0
Local i		   := 1
Local lCarencia:= .F.
Local lRetCar  := .T.
Local cTPCaren := SuperGetMV("MV_TPCAREN",.F.,"1")
Local nCont    := 0
Local lJurCar  := SEH->EH_JURCAR == "1"
Local lSEHBase := SEH->(ColumnPos("EH_BASEDES")) > 0

// Array com os campos utilizados na view
Local aCampos := {;
	{"PARCELA   ","N", 3,0},;
	{"DATAX     ","D", 8,0},;
	{"VALOR     ","N",14,2},;
	{"JUROS     ","N",14,2},;
	{"VCORRIGIDO","N",14,2},;
	{"AMORTIZA  ","N",14,2},;
	{"PRESTACAO ","N",14,2} }
	
Default cNumero := SEH->EH_NUMERO

//Limpa o codeblock bLoadGrd
If len(bLoadGrd) > 0
	aSize(bLoadGrd,0)
EndIf

// Verifica se j teve movimentao para o emprstimo e aborta visualizao
If nOpc == 9
	dbSelectArea("SEI")
	SEI->(DbSetOrder(1))
	If SEI->(DbSeek(xFilial("SEI")+"EMP"+cNumero)) 
		IW_MsgBox(STR0035,STR0017, "INFO" ) // //"Emprestimo Financeiro"
		Return .F.
	EndIf
EndIf

// Se o emprestimo no tem parcelas geradas no mostro a projeo das parcelas em tela.
If nOpc == 9
	dbSelectArea("SE2")
	SE2->(dbSetOrder(1))	//Prefixo+Numero+Parcela
	If !(SE2->(DbSeek(xFilial("SE2")+"EMP"+cNumero)))
		IW_MsgBox(STR0046, "INFO" ) // //"Emprestimos no possui parcelas."
		Return .F.
	Endif
Endif
	
dbSelectArea("SEH")

//Ŀ
// Cria arquivo de Trabalho   
//
If(_oXFINA171 <> NIL)
	_oXFINA171:Delete()
	_oXFINA171 := NIL
EndIf

_oXFINA171 := FwTemporaryTable():New("TRB")
_oXFINA171:SetFields(aCampos)
_oXFINA171:AddIndex("1",{"PARCELA"})
_oXFINA171:Create()

// Data de vencimento da primeira parcela (fixa 30 dias para teste)
//dPrimVenc := DaySum(SEH->EH_DATA,30) Nahim Quitando primera cuota obligatoria entre 30 
//dDataVenc := DaySum(SEH->EH_DATA,30) Nahim Quitando primera cuota obligatoria entre 30 
dPrimVenc := DaySum(SEH->EH_DATA,SEH->EH_UINTDIA)
dDataVenc := DaySum(SEH->EH_DATA,SEH->EH_UINTDIA)


// Valor do debito inicial
If lSEHBase
	If SEH->EH_BASEDES == "1" //Compe taxas e despesas na base de calculo dos juros
		nValDeb := SEH->EH_SALDO+SEH->EH_VALIOF+SEH->EH_TARIFA+SEH->EH_DESPESA+SEH->EH_SPREAD
	Else
		nValDeb := SEH->EH_SALDO
	Endif
Else 
	nValDeb := SEH->EH_SALDO
Endif

// Considera o valor informado no campo de amortizao
If !Empty(SEH->EH_VLAMORP)
	nValAmor := SEH->EH_VLAMORP
	If nOpc == 3
		IW_MsgBox(STR0034,STR0017, "INFO" ) //"Ser considerado para clculo o valor informado no campo Valor Amortizao/Parcela!" //"Emprestimo Financeiro"
	EndIf
Else
	// Calcula valor da amortizao
	nValAmor := Round(nValDeb/SEH->EH_PRAZO,2)
EndIf

// Verifica se emprestimo tem carncia
If !Empty(SEH->EH_CARENCI)
	lCarencia:= .T.
EndIf

// Preenche o temporario
While SEH->EH_NUMERO == cNumero .And. xFilial("SEH") == SEH->EH_FILIAL
	
	/*******************************************************************************************/
	/*******************************************************************************************/
	/*Calcula os valores com base no valor da amortizao/parcela informada no campo EH_VLAMORP*/
	/*******************************************************************************************/
	If Empty(SEH->EH_PRAZO) .And. !Empty(SEH->EH_VLAMORP)
		/**************/
		/* Tabela SAC */
		/**************/
		If SEH->EH_AMORTIZ == "2"	
			While nValDeb > nValAmor
			
				/*********** Emprestimo com Carncia***********/
				If lCarencia
					For i:=1 to SEH->EH_CARENCI
						If !lPriParc
							// Data de vencimento da parcela subsequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
						EndIf
						
						// Calcula o valor do debito
						nValDeb := nValDeb
						
						If SEH->EH_JURCAR == "1"	
							// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
							aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)
							nValJuros := Round(aCalculo[1][2],2)
						Else
							nValJuros := 0
						EndIf
						
						// Valor de amortizao  zero na carncia
						nValAmor := 0
						
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
						
						// Calcula o valor da prestao
						nValPrest := nValJuros
						
						/**********************************************/
						/*Grava o temporario com os valores calculados*/
						/**********************************************/	
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR		WITH	nValDeb
						REPLACE JUROS		WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA	WITH	nValAmor
						REPLACE PRESTACAO	WITH	nValPrest
						msUnlock()
						
						lPriParc := .F.
					
						//Totaliza totais de juros e prestao
						nTotJuros += nValJuros
						nTotPrest += nValPrest
				
						// Soma uma parcela
						nParcela++							
					Next i	
					
					// Define carncia como falso para seguir o clculo das parcelas
					lCarencia := .F.				
				
				/***********Calculo sem Carncia***********/
				Else
					// Valor de amortizao
					nValAmor := SEH->EH_VLAMORP
					
					If !lPriParc
						// Data de vencimento da parcela sequente
					//	dDataVenc := DaySum(TRB->DATAX,30)
						dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
						
						// Calcula o valor do debito
						nValDeb := nValDeb - nValAmor		
					EndIf
					
					// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
					aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
			
					// Calcula o valor dos juros
					nValJuros := Round(aCalculo[1][2],2)
					
					// Calcula o valor corrigido
					nValCorr := nValDeb + nValJuros
					
					// Calcula o valor da prestao
					nValPrest := nValJuros + nValAmor
						
					/**********************************************/
					/*Grava o temporario com os valores calculados*/
					/**********************************************/	
					If nValDeb < nValAmor
						// Grava o valor da ltima parcela
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR			WITH	nValDeb
						REPLACE JUROS			WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA		WITH	nValDeb
						REPLACE PRESTACAO		WITH	nValCorr
						msUnlock()
						
						// Atualiza o total com o valor da ultima parcela
						nValPrest := nValCorr
						
					Else
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR			WITH	nValDeb
						REPLACE JUROS			WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA		WITH	nValAmor
						REPLACE PRESTACAO		WITH	nValPrest
						msUnlock()
					EndIf
					
					lPriParc := .F.
					
					//Totaliza totais de juros e prestao
					nTotJuros += nValJuros
					nTotPrest += nValPrest
			
					// Soma uma parcela
					nParcela++	
						
				EndIf
			Enddo
						
		/****************/
		/* Tabela PRICE */	
		/****************/	
		Else
			While nValDeb > nValPrest
				
				/*********** Emprestimo com Carncia***********/
				If lCarencia
					For i:=1 to SEH->EH_CARENCI
						If !lPriParc
							// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
						EndIf
						
						// Calcula o valor do debito
						nValDeb := nValDeb
						
						If SEH->EH_JURCAR == "1"	
							// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
							aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)
							nValJuros := Round(aCalculo[1][2],2)
						Else
							nValJuros := 0
						EndIf
						
						// Valor de amortizao  zero na carncia
						nValAmor := 0
						
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
						
						// Calcula o valor da prestao
						nValPrest := nValJuros
						
						/**********************************************/
						/*Grava o temporario com os valores calculados*/
						/**********************************************/	
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR		WITH	nValDeb
						REPLACE JUROS		WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA	WITH	nValAmor
						REPLACE PRESTACAO	WITH	nValPrest
						msUnlock()
						
						lPriParc := .F.
					
						//Totaliza totais de juros e prestao
						nTotJuros += nValJuros
						nTotPrest += nValPrest
				
						// Soma uma parcela
						nParcela++							
					Next i	
					
					// Define carncia como falso para seguir o clculo das parcelas
					lCarencia := .F.
					
				/***********Calculo sem Carncia***********/	
				Else
				
					// Valor de amortizao
					nValPrest := SEH->EH_VLAMORP
					
					If !lPriParc
						// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
					EndIf
						
					// Recalcula o valor do debito quando no for a primeira parcela
					If !lPriParc			
						// Calcula o valor do debito
						nValDeb := nValDeb - nValAmor
					EndIf
						
					// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
					aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
				
					// Calcula o valor dos juros
					nValJuros := Round(aCalculo[1][2],2)
						
					// Calcula o valor da prestao para o sistema PRICE
					If lPriParc
						// Calcula a taxa de juros mensal
						nTaxaJur := nValJuros/nValDeb
							
						// Considera o valor da parcela informada no campo EH_VLAMORP
						nValPrest := SEH->EH_VLAMORP
	
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
					EndIf
						
					// Calcula valor da amortizao
					nValAmor := nValPrest - nValJuros
						
					If !lPriParc
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
					EndIf	
					
					/**********************************************/
					/*Grava o temporario com os valores calculados*/
					/**********************************************/
					If nValDeb < nValPrest
						// Grava o valor da ltima parcela
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR		WITH	nValDeb
						REPLACE JUROS		WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA	WITH	nValDeb
						REPLACE PRESTACAO	WITH	nValCorr
						msUnlock()	
						
						// Atualiza o total com o valor da ultima parcela
						nValPrest := nValCorr
									
					Else
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR			WITH	nValDeb
						REPLACE JUROS			WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA		WITH	nValAmor
						REPLACE PRESTACAO		WITH	nValPrest
						msUnlock()
					EndIf
							
					lPriParc := .F.
					
					//Totaliza totais de juros e prestao
					nTotJuros += nValJuros
					nTotPrest += nValPrest
			
					// Soma uma parcela
					nParcela++
				EndIf
			Enddo
		EndIf
			
			
	/*********************************************************************************/
	/*********************************************************************************/
	/*Calcula os valores com base no prazo informado no campo EH_PRAZO					*/
	/*********************************************************************************/
	Else
	
		nCont := IIF(cTPCaren=="1",SEH->EH_PRAZO - SEH->EH_CARENCI, SEH->EH_PRAZO) //Determina se a carncia  considera dentro ou fora do prazo informado

		For nI := 1 to nCont
			
			/**************/
			/* Tabela SAC */
			/**************/
			If SEH->EH_AMORTIZ == "2"	
			
				/*********** Emprestimo com Carncia***********/
				If lCarencia
					For i:=1 to SEH->EH_CARENCI
						If !lPriParc
							// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
						EndIf
						
						// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFIN
						aCalculo  := Fa171Calc(dPrimVenc, nValDeb, .F.)
						nValJuros := Round(aCalculo[1][2],2)
						
						// Valor de amortizao  zero na carncia
						nValAmor := 0
						
						//Calcula o valor corrigido, considerando ou no os juros na carencia conforme definido no campo EH_JURCAR
						nValCorr := IIF(lJurCar, nValDeb, nValDeb+nValJuros)
						
						//Calcula a prestao no periodo de carencia considerando os juros caso definido no campo EH_JURCAR
						nValPrest := IIF(lJurCar, nValJuros, 0)

						/**********************************************/
						/*Grava o temporario com os valores calculados*/
						/**********************************************/	
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR		WITH	nValDeb
						REPLACE JUROS		WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA	WITH	nValAmor
						REPLACE PRESTACAO	WITH	nValPrest
						msUnlock()
						
						lPriParc := .F.
						nValDeb  := nValCorr //Atualiza coluna valor debito com o valor corrigido, para assim exibir o valor debito correto na proxima parcela
					
						//Totaliza totais de juros e prestao
						nTotJuros += nValJuros
						nTotPrest += nValPrest
				
						// Soma uma parcela
						nParcela++							
					Next i					
					
					// Define carncia como falso para seguir o clculo das parcelas
					lCarencia := .F.
					lRetCar   := .F.
					lPriParc  := .T.
					nI := 0 // Volta uma posio do for para calcular a quantidade certa de parcelas
				
					Loop

				/***********Calculo sem Carncia***********/		
				Else
				
					If lPriParc
						// Calcula valor da amortizao
						If cTPCaren == "1"					
							nValAmor := Round(nValDeb/(SEH->EH_PRAZO-SEH->EH_CARENCI),2)
						ElseIf cTPCaren == "2"
							// Carencia fora do prazo do emprestimo
							nValAmor := Round(nValDeb/SEH->EH_PRAZO,2) 
						EndIf
					Endif				

					If nParcela > 1 .And. lPriParc
						// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
					EndIf

					If !lPriParc
						// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
						
						// Calcula o valor do debito
						nValDeb := nValDeb - nValAmor		
					EndIf
					
					// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
					aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
			
					// Calcula o valor dos juros
					nValJuros := Round(aCalculo[1][2],2)
					
					// Calcula o valor corrigido
					nValCorr := nValDeb + nValJuros
					
					// Calcula o valor da prestao
					nValPrest := nValJuros + nValAmor
					
					lRetCar   := .T. // Define variavel para impressao
				EndIf
			
			/****************/
			/* Tabela PRICE */	
			/****************/
			Else
			
				/*********** Emprestimo com Carncia***********/
				If lCarencia
					For i:=1 to SEH->EH_CARENCI
						If !lPriParc
							// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
						EndIf
						
						// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFIN
						aCalculo  := Fa171Calc(dPrimVenc, nValDeb, .F.)
						nValJuros := Round(aCalculo[1][2],2)

						// Valor de amortizao  zero na carncia
						nValAmor := 0
						
						//Calcula o valor corrigido, considerando ou no os juros na carencia conforme definido no campo EH_JURCAR
						nValCorr := IIF(lJurCar, nValDeb, nValDeb+nValJuros)
						
						//Calcula a prestao no periodo de carencia considerando os juros caso definido no campo EH_JURCAR
						nValPrest := IIF(lJurCar, nValJuros, 0)
						
						/**********************************************/
						/*Grava o temporario com os valores calculados*/
						/**********************************************/	
						RecLock( "TRB", .T. )
						REPLACE PARCELA		WITH	nParcela
						REPLACE DATAX      	WITH	dDataVenc
						REPLACE VALOR		WITH	nValDeb
						REPLACE JUROS		WITH	nValJuros
						REPLACE VCORRIGIDO	WITH	nValCorr
						REPLACE AMORTIZA	WITH	nValAmor
						REPLACE PRESTACAO	WITH	nValPrest
						msUnlock()
						
						lPriParc := .F.
						nValDeb  := nValCorr //Atualiza coluna valor debito com o valor corrigido, para assim exibir o valor debito correto na proxima parcela
					
						//Totaliza totais de juros e prestao
						nTotJuros += nValJuros
						nTotPrest += nValPrest		
						
						// Soma uma parcela
						nParcela++			
					Next i					
					
					// Define carncia como falso para seguir o clculo das parcelas
					lCarencia := .F.
					lRetCar   := .F.
					lPriParc  := .T.
					nI := 0 // Volta uma posio do for para calcular a quantidade certa de parcelas

					Loop
				
				/***********Calculo sem Carncia***********/
				Else
					
					If nParcela > 1 .And. lPriParc
						// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
					EndIf

					If !lPriParc
						// Data de vencimento da parcela sequente
						//	dDataVenc := DaySum(TRB->DATAX,30)
							dDataVenc := DaySum(TRB->DATAX,SEH->EH_UINTDIA) // Nahim Cambiando amotizacin 
					EndIf
					
					// Recalcula o valor do debito quando no for a primeira parcela
					If !lPriParc			
						// Calcula o valor do debito
						nValDeb := nValDeb - nValAmor
					EndIf
					
					// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
					aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
			
					// Calcula o valor dos juros
					nValJuros := Round(aCalculo[1][2],2)
					
					// Calcula o valor da prestao para o sistema PRICE
					If lPriParc
						// Calcula a taxa de juros mensal
						nTaxaJur := nValJuros/nValDeb
	
						// Calcula o valor da prestao
						If cTPCaren = "1"
							If nTaxaJur > 0
								nValPrest := nValDeb*(((1+nTaxaJur)^(SEH->EH_PRAZO-SEH->EH_CARENCI))*nTaxaJur/(((1+nTaxaJur)^(SEH->EH_PRAZO-SEH->EH_CARENCI))-1))
							Else
								nValPrest := nValDeb/(SEH->EH_PRAZO-SEH->EH_CARENCI)
							EndIf
						ElseIf cTPCaren = "2"	
							If nTaxaJur > 0
								// Carencia fora do prazo do emprestimo
								nValPrest := nValDeb*(((1+nTaxaJur)^SEH->EH_PRAZO)*nTaxaJur/(((1+nTaxaJur)^SEH->EH_PRAZO)-1))
							Else						
								nValPrest := nValDeb/SEH->EH_PRAZO
							EndIf
						EndIf 
						
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
					EndIf
					
					// Calcula valor da amortizao
					nValAmor := nValPrest - nValJuros
					
					If !lPriParc
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
					EndIf
					
					lRetCar   := .T. // Define variavel para impressao
				EndIf
			EndIf			

			If lRetCar
				/**********************************************/
				/*Grava o temporario com os valores calculados*/
				/**********************************************/
				RecLock( "TRB", .T. )
				REPLACE PARCELA		WITH	nParcela
				REPLACE DATAX      	WITH	dDataVenc
				REPLACE VALOR		WITH	nValDeb
				REPLACE JUROS		WITH	nValJuros
				REPLACE VCORRIGIDO	WITH	nValCorr
				REPLACE AMORTIZA	WITH	nValAmor
				REPLACE PRESTACAO	WITH	nValPrest
				msUnlock()
				
				// Soma uma parcela
				nParcela++					
				lPriParc := .F.	
			EndIf
			
			//Totaliza totais de juros e prestao
			nTotJuros += nValJuros
			nTotPrest += nValPrest

		Next
	EndIf
	
	// Ajusta valor total das parcelas quando emprstimo com carncia 
	If SEH->EH_AMORTIZ == "2" .And. !Empty(SEH->EH_CARENCI) .And. !Empty(SEH->EH_VLAMORP)
		nTotPrest := nTotPrest + nValAmor
	EndIf
	
	// Grava o total do emprestimo/financiamento no temporario
	RecLock( "TRB", .T. )
	REPLACE PARCELA		WITH	999
	REPLACE VALOR			WITH	0
	REPLACE JUROS			WITH	nTotJuros
	REPLACE VCORRIGIDO	WITH	0
	REPLACE AMORTIZA		WITH	SEH->EH_SALDO
	REPLACE PRESTACAO		WITH	nTotPrest
	msUnlock()	

	SEH->( dbSkip() )
Enddo

/******************************************************/
/*Grava os valores do temporario no codeblock bLoadGrd*/
/******************************************************/
TRB->(dbGoTop())
While !TRB->(eof())
	aAdd(bLoadGrd,{0,{TRB->PARCELA, TRB->DATAX, TRB->VALOR, TRB->JUROS,TRB->VCORRIGIDO ,TRB->AMORTIZA ,TRB->PRESTACAO}})
	TRB->(dbSkip())
Enddo


If nOpc <> 3
	// Fecha o arquivo temporario
	If(_oXFINA171 <> NIL)
		_oXFINA171:Delete()
		_oXFINA171 := NIL
	EndIf
EndIf

Return lRet  //Static Function FC171Par

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171_V
Visualiza o calculo das parcelas para apresentacao em tela

@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
*/
//------------------------------------------------------------------------------------------

STATIC Function FC171_V()

Local cTitulo    := ""
Local cPrograma  := 'XFinA171'
Local nOperation := MODEL_OPERATION_VIEW
Local lRet		   := .T.
Local nOpc		   := 9

//Apresenta uma tela demonstrando os valores do Contrato bem como o valor que dever ser pago em cada parcela
If SEH->EH_TIPO == 'EMP' .And. !Empty(SEH->EH_AMORTIZ)

	cNumero := SEH->EH_NUMERO
	//Carrega as parcelas no arquivo temporario
	MsgRun(STR0033,, { || lRet := FC171Par(cNumero,nOpc) }  ) //"Aguarde, realizando o calculo das parcelas...
EndIf

If lRet
	// Chama a view da tabela SEH
	lRetorna := FWExecView(cTitulo , cPrograma, nOperation, /*oDlg*/, {|| .T. } ,/*bOk*/ , /*nPercReducao*/, /*aEnableButtons*/, /*bCancel*/ , /*cOperatId*/, /*cToolBar*/, /*oModel*/ )
EndIf

Return()


//-------------------------------------------------------------------
/*/{Protheus.doc} MontaSCab()
Retorna estrutura do tipo FWformModelStruct.

@author Ronaldo Tapia

@since 27/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------

Static function MontaSCab()

Local aArea    := GetArea()
Local oStruct := FWFormModelStruct():New()

// Tabela
oStruct:AddTable('SEH',{'PARCELA','DATAX','VALOR','JUROS','VCORRIGIDO','AMORTIZA','PRESTACAO'},"Cabealho do TRB")// Campos do cabealho do TRB

// Campos
oStruct:AddField(	STR0068						,; 	// [01] C Titulo do campo // "Parcela"
					STR0068						,; 	// [02] C ToolTip do campo // "Parcela"
					"PARCELA"	 				,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					3							,; 	// [05] N Tamanho do campo
					0 							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual
					
oStruct:AddField(	STR0069						,; 	// [01] C Titulo do campo // "Vencimento"
					STR0069						,; 	// [02] C ToolTip do campo // "Vencimento"
					"DATA" 						,; 	// [03] C identificador (ID) do Field
					"D" 						,; 	// [04] C Tipo do campo
					8							,; 	// [05] N Tamanho do campo
					0 							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
					
oStruct:AddField(	STR0070						,; 	// [01] C Titulo do campo // "Valor do Dbito"
					STR0070						,; 	// [02] C ToolTip do campo // "Valor do Dbito"
					"VALOR" 					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
					
oStruct:AddField(	STR0071						,; 	// [01] C Titulo do campo // "Juros"
					STR0071						,; 	// [02] C ToolTip do campo // "Juros"
					"JUROS" 					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,;  // [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
	
oStruct:AddField(	STR0072						,; 	// [01] C Titulo do campo // "Valor Corrigido"
					STR0072						,; 	// [02] C ToolTip do campo // "Valor Corrigido"
					"VCORRIGIDO"				,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil 						,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	

oStruct:AddField(	STR0073						,; 	// [01] C Titulo do campo // "Amortizao"
					STR0073						,; 	// [02] C ToolTip do campo // "Amortizao"
					"AMORTIZA" 					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2 							,; 	// [06] N Decimal do campo
					Nil 						,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
	
oStruct:AddField(	STR0074						,; 	// [01] C Titulo do campo // "Prestao"
					STR0074						,; 	// [02] C ToolTip do campo // "Prestao"
					"PRESTACAO"					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil 						,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual		
					
// Indices
oStruct:AddIndex( 	1	      						, ;     // [01] Ordem do indice
					"01"   							, ;     // [02] ID
					"PARCELA"				  		, ;		// [03] Chave do indice
					"Indice 1" + " + " + "Parcela"	, ;     // [04] Descrio do indice
					""       						, ;		// [05] Expresso de lookUp dos campos de indice (SIX_F3)
					"" 								, ;		// [06] Nickname do indice
					.T. )      								// [07] Indica se o indice pode ser utilizado pela interface
					
oStruct:AddIndex( 	2	      						, ;     // [01] Ordem do indice
					"02"   							, ;     // [02] ID
					"DATAX"				  		    , ; 	// [03] Chave do indice
					"Indice 2" + " + " + "Data"		, ;     // [04] Descrio do indice
					""       						, ;		// [05] Expresso de lookUp dos campos de indice (SIX_F3)
					"" 								, ;		// [06] Nickname do indice
					.T. )    

RestArea( aArea )

Return oStruct   

//-------------------------------------------------------------------
/*/{Protheus.doc} MontaSView()
Retorna estrutura do tipo FWFormViewStruct.

@author Ronaldo Tapia

@since 27/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------

Static function MontaSView()
Local oStruct   := FWFormViewStruct():New()

		/* Estutura para a criao de campos na view	
		
			[01] C Nome do Campo
			[02] C Ordem
			[03] C Titulo do campo  
			[04] C Descrio do campo  
			[05] A Array com Help
			[06] C Tipo do campo
			[07] C Picture
			[08] B Bloco de Picture Var
			[09] C Consulta F3
			[10] L Indica se o campo  editvel
			[11] C Pasta do campo
			[12] C Agrupamento do campo
			[13] A Lista de valores permitido do campo (Combo)
			[14] N Tamanho Maximo da maior opo do combo
			[15] C Inicializador de Browse
			[16] L Indica se o campo  virtual
			[17] C Picture Varivel
	
		*/

// Campos
oStruct:AddField("PARCELA",    "01", STR0068, STR0068, {}, "N", "@E 999"		   , /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("DATA",       "02", STR0069, STR0069, {}, "D", "@!"			   , /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("VALOR",      "03", STR0070, STR0070, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("JUROS",      "04", STR0071, STR0071, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("VCORRIGIDO", "05", STR0072, STR0072, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("AMORTIZA",   "06", STR0073, STR0073, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("PRESTACAO",  "07", STR0074, STR0074, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 

Return oStruct

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCGrvE2
Funo para gravao das parcelas no contas a pagar (SE2)

@author    Ronaldo Tapia
@version   11.80
@since     04/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

user Function FCGrvE2(cArqTmp,cNumero)

Local aArray	:= {}
Local cParcela	:= ""
Local dData		:= STOD("")
Local nValor	:= 0
Local nJuros	:= 0
Local aArea		:= GetArea()
Local nTamFor	:= TamSX3("E2_FORNECE")[1]
Local cForPar	:= PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"),nTamFor)
Local nNumReg	:= Len(bLoadGrd)
Local nTotVal	:= 0
 
Private lMsErroAuto := .F.

If Empty(cCodFor)
	cCodFor := cForPar
	
	DbSelectArea("SA2")
	SA2->( DbSetOrder(1) )
	
	If SA2->( DbSeek( xFilial("SA2") + cCodFor ) )
		cForLj := SA2->A2_LOJA
	EndIf
EndIf

// Posiciona no arquivo correto
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

ProcRegua(nNumReg)

(cArqTmp)->(dbGoTop())
nContador := 1 // Nahim Adicion de contador de cuotas. 03/12/2019
While (cArqTmp)->(!EOF()) 
// Nahim Adicion de contador de cuotas. 03/12/2019
	cParcela	:= cValtoChar((cArqTmp)->PARCELA)
	If cParcela <> "999" //.And. nValor > 0     
	Reclock(cArqTmp,.F.)
		replace	(cArqTmp)->VALOR		WITH	aCuotas[nContador,2]
		replace	(cArqTmp)->JUROS		WITH	aCuotas[nContador,3]
		replace	(cArqTmp)->VCORRIGIDO	WITH	aCuotas[nContador,4]
		replace	(cArqTmp)->AMORTIZA	WITH	aCuotas[nContador,5]
		replace	(cArqTmp)->PRESTACAO 	WITH	aCuotas[nContador,6]
		replace	(cArqTmp)->DATAX 	WITH	aCuotas[nContador,7]
	msUnlock()	
	endif
	nContador++
// Nahim Adicion de contador de cuotas. 03/12/2019
	BEGIN TRANSACTION
	
	// Alimenta barra de progresso
   IncProc(STR0032+cParcela) //"Gravando Parcela: "                 

	cParcela	:= cValtoChar((cArqTmp)->PARCELA)
	dData		:= (cArqTmp)->DATAX
	nValor		:= (cArqTmp)->PRESTACAO
	nJuros		:= (cArqTmp)->JUROS
	
	// Tratamento para parcelas com carncia, grava somente o valor dos juros
	If (cArqTmp)->AMORTIZA == 0 .And. (cArqTmp)->JUROS > 0
		nValor := 0.01
	EndIf
 
 	// Ajusta valor da ltima parcela
 	If cParcela == cValtoChar(nNumReg - 1)
 		If nTotVal + (cArqTmp)->AMORTIZA < SEH->EH_FINANC
 			nValor := Round(SEH->EH_FINANC - nTotVal,2) + (cArqTmp)->JUROS
 		EndIf
 	EndIf

	aArray := {	{ "E2_PREFIXO"  , "EMP"             , NIL },;
					{ "E2_NUM"      , SEH->EH_NUMERO    , NIL },;
					{ "E2_PARCELA"  , cParcela          , NIL },;
					{ "E2_TIPO"     , "PR"              , NIL },;
					{ "E2_NATUREZ"  , SEH->EH_NATUREZA  , NIL },;
            		{ "E2_FORNECE"  , cCodFor           , NIL },;
            		{ "E2_LOJA"		, cForLj            , NIL },;
            		{ "E2_EMISSAO"  , SEH->EH_DATA		, NIL },;
            		{ "E2_VENCTO"   , dData				, NIL },;            	
            		{ "E2_JUROS"    , nJuros			, NIL },;
            		{ "E2_MOEDA"    , SEH->EH_MOEDA		, NIL },;
            		{ "E2_VALOR"    , nValor			, NIL },;
            		{ "E2_HIST"    , 'PRESTAMO: ' + SEH->EH_NUMERO + ' - CUOTA ' + CPARCELA	, NIL },;
					{ "E2_ORIGEM"   , "XFINA171"			, NIL } }
	
	nTotVal += (cArqTmp)->AMORTIZA
     
	// S grava a parcela se for diferente de 999 e maior que zero
	If cParcela <> "999" .And. nValor > 0    
		// Grava os valores no SE2
		MsExecAuto( { |x,y,z| FINA050(x,y,z)}, aArray,, 3)  // 3 - Inclusao, 4 - Alterao, 5 - Excluso
		If lMsErroAuto
    		MostraErro()
			DisarmTransaction()
		Endif
	EndIf
		
	END TRANSACTION

	If lMsErroAuto
		Exit
	Endif

	(cArqTmp)->(dbSkip())
EndDo
 
// Mostra erro
If !lMsErroAuto
	IW_MsgBox(STR0031,STR0017, "INFO" ) //"Parcelas includas com sucesso!" //"Emprestimo Financeiro"
Endif

// Fecha o arquivo temporario
If(_oXFINA171 <> NIL)
	_oXFINA171:Delete()
	_oXFINA171 := NIL
EndIf

RestArea(aArea)


Return	

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCGrvE5
Funo para gravao das despesas do contrato na SE5

@author    Ronaldo Tapia
@version   11.80
@since     04/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FCGrvE5(cNumero,lEstorno)

Local nValor 	   := 0
Local cHistorico := ""
Local lUsaFlag   := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local lAtuSldNat := FindFunction("AtuSldNat") .AND. AliasInDic("FIV") .AND. AliasInDic("FIW")
Local nMoedaBco	 := 1	

Local oModelMov := FWLoadModel("FINM030") //Model de Movimento Bancrio
Local oSubFK5
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local cCamposE5 := ""
Local cSinal	:= ""

DEFAULT lEstorno	:= .F.

If lEstorno
//	cHistorico := STR0075 //"Estorno Desp.Emprestimo/Financ."
	cHistorico := "Retorno de prestamos financiero" //"Estorno Desp.Emprestimo/Financ."
Else
	cHistorico := STR0030 //"Despesas Emprestimos/Financiamentos"
EndIf

// Posiciona no arquivo correto
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

dbSelectArea('SA6')
dbSetOrder(1)
If dbSeek(xFilial()+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA)
	nMoedaBco := Max(SA6->A6_MOEDA,1)
EndIf

// Calcula o valor das despesas
If !Empty(SEH->EH_SPREAD)
	If SEH->EH_MOEDA > 1	
		nValor := xMoeda(SEH->EH_DESPESA + SEH->EH_SPREAD,SEH->EH_MOEDA,nMoedaBco)
	Else
		nValor := SEH->EH_DESPESA + SEH->EH_SPREAD
	EndIf
Else
	If SEH->EH_MOEDA > 1
		nValor := 	xMoeda(((SEH->EH_FINANC*SEH->EH_PSPREAD)/100) + SEH->EH_DESPESA,SEH->EH_MOEDA,nMoedaBco)		
	Else
		nValor := ((SEH->EH_FINANC*SEH->EH_PSPREAD)/100) + SEH->EH_DESPESA
	EndIf
EndIf

If nValor > 0
	cCamposE5 += "{"		
	cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
	cCamposE5 += "}"
				
	oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento 
	oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
	oModelMov:Activate()
	oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou no
	oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que sero gravados indepentes de FK5 
	oModelMov:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a incluso no ser feita com um novo nmero de processo
					
	//Dados do Processo
	oSubFKA := oModelMov:GetModel("FKADETAIL")
	oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
	oSubFKA:SetValue( "FKA_TABORI", "FK5" )
	
	//Informacoes do movimento
	oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
	If lEstorno
		oSubFK5:SetValue( "FK5_DATA", dDataBase )
		oSubFK5:SetValue( "FK5_RECPAG","R" )
		oSubFK5:SetValue( "FK5_DTDISP", dDataBase )
	Else
		oSubFK5:SetValue( "FK5_DATA", SEH->EH_DATA )
		oSubFK5:SetValue( "FK5_RECPAG","P" )
		oSubFK5:SetValue( "FK5_DTDISP", SEH->EH_DSPREAD )
	EndIf
	oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
	oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
	oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )				
	oSubFK5:SetValue( "FK5_VALOR", nValor )
	If SEH->EH_MOEDA <> 1
		oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nValor, 1, SEH->EH_MOEDA ) )
	EndIf
	oSubFK5:SetValue( "FK5_TPDOC", "DB" )
	oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
	oSubFK5:SetValue( "FK5_MOEDA", "01" )			
	oSubFK5:SetValue( "FK5_FILORI", SEH->EH_FILIAL )
	oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
	oSubFK5:SetValue( "FK5_ORIGEM", FunName() )				
	If lUsaFlag .and. ( MV_PAR02 == 1 )
		oSubFK5:SetValue( "FK5_LA", "S" )
	Endif
	oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )
					
	If oModelMov:VldData()		
		oModelMov:CommitData()
	    oModelMov:DeActivate()
	Else
		lRet := .F.
		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
	    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
	    cLog += cValToChar(oModelMov:GetErrorMessage()[6]) 
	    
	    Help( ,,"MF171EXC",,cLog, 1, 0 )	            
	Endif
					
	If lRet
		cSinal	:= IIf(SE5->E5_RECPAG == "R", "+", "-") 
		AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,cSinal)
						
		 // Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
		If lAtuSldNat			
			AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", "P", SEH->EH_DESPESA, 0, Iif(lEstorno,"-","+"),,FunName(),"SE5", SE5->(Recno()),0)
		EndIf
	Endif
EndIf

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171VPAR
Faz verificacao do numero de parcelas do contrato de emprestimo/Financiamento

@author    Ronaldo Tapia
@version   11.80
@since     04/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

static Function FC171VPAR(nParceEmp)

Local nMaxParc  := 0
Local nTamParc  := TAMSX3("E2_PARCELA")[1]

Default nParceEmp := M->EH_PRAZO

// Tamanho do campo Parcela
If nTamParc == 1  
	nMaxParc := 9
ElseIf nTamParc==2
	nMaxParc := 99
Else
	nMaxParc := 999
Endif

//Validaes do tamanho do campo E2_PARCELA
If nParceEmp > nMaxParc
	MsgInfo(STR0020+STR(nMaxParc)+STR0021,STR0017) //"Nmero mximo de parcelas: " // " Para aumentar altere o grupo de campos PARCELA." //"Emprestimo Financeiro"
	Return .F.
Endif

If !Empty(M->EH_PRAZO) .And. !Empty(M->EH_VLAMORP)
	MsgInfo(STR0022,STR0017) //"Se o valor de parcela/amortizao estiver preenchido no  possvel definir o campo Prazo!" //"Emprestimo Financeiro"
	Return .F.
EndIf

Return .T.

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171VEnt
Validao no valor da entrada (EH_ENTRADA)

@author    Ronaldo Tapia
@version   11.80
@since     07/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

static Function FC171VEnt()

//Validaes do tamanho do campo E2_ENTRADA
If M->EH_ENTRADA > M->EH_VALOR 
	MsgInfo(STR0023,STR0017) //"Valor da entrada no pode ser maior que o valor da operao!" //"Emprestimo Financeiro"
Endif

Return .T.

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171VAm
Validao no valor da parcela/amortizacao (EH_PRAZO)

@author    Ronaldo Tapia
@version   11.80
@since     07/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

static Function FC171VAm(nValAmor)

Default nValAmor := M->EH_VLAMORP

//Validaes do tamanho do campo EH_VLAMORP
If !Empty(M->EH_VLAMORP) .And. !Empty(M->EH_PRAZO) 
	MsgInfo(STR0024,STR0017) //"Se o Prazo estiver preenchido no  possvel definir um valor de parcela/amortizao!"  //"Emprestimo Financeiro"
	Return .F.
EndIf

Return .T.

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171Imp
Imprime os dados do contrato com cabealho e parcelas provisrias

@author    Ronaldo Tapia
@version   11.80
@since     11/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

static Function FC171Imp()

Local oReport := Nil	
Local cPerg:= "FC171Imp"

oReport := RptDef(cPerg)
oReport:PrintDialog()

Return

// Monta a estrutura das sees do relatrio
Static Function RptDef(cNome)

Local oReport  := Nil
Local oSection1:= Nil
Local oSection2:= Nil
	
/*Sintaxe: TReport():New(cNome,cTitulo,cPerguntas,bBlocoCodigo,cDescricao)*/
oReport := TReport():New(cNome,STR0028,cNome,{|oReport| ReportPrint(oReport)},STR0029) //"Contrato de Emprstimo - Demonstrativo Mensal" //"Demonstrativo das parcelas do contrato de emprstimo" 
oReport:SetPortrait()    
oReport:lParamPage := .F.
	
oSection1:= TRSection():New(oReport, "CONTRATO", {"SEH"}, , .F., .T.)
TRCell():New(oSection1,"EH_NUMERO"		,"SEH","N Contrato",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_TAXA"		,"SEH","Taxa",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_VALOR"		,"SEH","Valor",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_ENTRADA"	,"SEH","Valor Entrada",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_FINANC"		,"SEH","Valor Financiado",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_PRAZO"		,"SEH","Prazo",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_CARENCI"	,"SEH","Carncia",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_AMORTIZ"	,"SEH","Amortizao",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection1,"EH_VLAMORP"	,"SEH","Valor Amortizao/Parcela",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
	
oSection2:= TRSection():New(oReport, "PARCELAS", {"TRB"}, NIL, .F., .T.)
TRCell():New(oSection2,"PARCELA"   	,"TRB","Parcela",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection2,"DEBITO"  		,"TRB","Valor Debito","@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection2,"VENC"			,"TRB","Vencimento",/*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection2,"JUROS"			,"TRB","Juros",PesqPict("SE2","E2_JUROS" ),TamSX3("E2_JUROS" )[1],/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection2,"CORRIG"			,"TRB","Valor Corrigido","@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection2,"AMORTIZ"		,"TRB","Amortizao","@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)	
TRCell():New(oSection2,"PRESTA"			,"TRB","Prestao","@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
TRCell():New(oSection2,"SALDO"			,"TRB","Saldo",PesqPict("SE2","E2_SALDO" ),TamSX3("E2_SALDO" )[1],/*lPixel*/,/*{|| code-block de impressao }*/)		

Return(oReport)


// Imprime os dados do contrato e o demonstrativo das parcelas provisrias
// geradas no contas a pagar (SE2)
Static Function ReportPrint(oReport)

Local oSection1 := oReport:Section(1)
Local oSection2 := oReport:Section(2)	 
Local cNumero   := ""
Local cAliasQry := GetNextAlias()
Local cQuery	  := " "
Local nValCorr  := 0
Local nValPres  := 0
Local nValDeb   := 0
Local nValor    := 0
Local nTotJur   := 0
Local nTotPres  := 0
Local dDtvenc   := STOD("")
Local dDataIni  := STOD("")
Local nSaldo    := 0

If oReport:Cancel()
	Return .T.
EndIf

//Apresenta relatrio demonstrando os valores do Contrato bem como o valor que dever ser pago em cada parcela
cNumero := SEH->EH_NUMERO

// Inicializo a primeira seo
oSection1:Init()
oReport:IncMeter()

// Posiciona no arquivo correto da SEH
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))
				
IncProc(STR0027) //"Imprimindo parcelas do contrato de emprstimo"
		
// Imprimo a primeira seo				
oSection1:Cell("EH_NUMERO"):SetValue(SEH->EH_NUMERO)
oSection1:Cell("EH_TAXA"):SetValue(SEH->EH_TAXA)
oSection1:Cell("EH_VALOR"):SetValue(SEH->EH_VALOR)	
oSection1:Cell("EH_ENTRADA"):SetValue(SEH->EH_ENTRADA)	
oSection1:Cell("EH_FINANC"):SetValue(SEH->EH_FINANC)	
oSection1:Cell("EH_PRAZO"):SetValue(SEH->EH_PRAZO)	
oSection1:Cell("EH_CARENCI"):SetValue(SEH->EH_CARENCI)	
If SEH->EH_AMORTIZ == "1"
	oSection1:Cell("EH_AMORTIZ"):SetValue("Price")
Else
	oSection1:Cell("EH_AMORTIZ"):SetValue("SAC")
EndIf	
oSection1:Cell("EH_VLAMORP"):SetValue(SEH->EH_VLAMORP)	
				
oSection1:Printline()
		
// Inicializo e imprimo a segunda seo
oSection2:init()

// Query para buscar as parcelas no contas a pagar
cQuery:=''
cQuery:= " SELECT E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_VALOR, E2_VENCREA, E2_JUROS, E2_SALDO "
cQuery+= " FROM "+RetSqlName("SE2")+" SE2 "
cQuery+= " WHERE SE2.D_E_L_E_T_ =' ' "
cQuery+= " AND E2_FILIAL = '"+xFilial("SEH")+"' "
cQuery+= " AND E2_PREFIXO = 'EMP' "
cQuery+= " AND E2_NUM = '"+cNumero+"' "
cQuery+= " ORDER BY E2_VENCREA "

cQuery := ChangeQuery(cQuery)

If (Select(cAliasQry) <> 0)
	dbSelectArea(cAliasQry)
	dbCloseArea()
Endif
dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

Dbselectarea(cAliasQry)
dbgotop()

// Valor do Debito total do emprstimo
nValDeb := SEH->EH_FINANC

While (cAliasQry)->(!EOF())

	// Se prestao for de 0.01 apresenta valor de 0
	If (cAliasQry)->E2_VALOR <> 0.01
		nValor   := (cAliasQry)->E2_VALOR - (cAliasQry)->E2_JUROS
		nValPres := (cAliasQry)->E2_VALOR
	Else
		nValor   := 0
		nValPres := (cAliasQry)->E2_JUROS
	EndIf
	
	// Calcula o valor corrigido e da prestao
	nValCorr := nValDeb + (cAliasQry)->E2_JUROS
	dDtvenc  := STOD((cAliasQry)->E2_VENCREA)
	
	// Formato saldo para apresentao
	If (cAliasQry)->E2_SALDO == 0
		nSaldo := 0
	Else
		nSaldo   := (cAliasQry)->E2_SALDO// + (cAliasQry)->E2_JUROS 
	EndIf

	IncProc(STR0027) //"Imprimindo parcelas do contrato de emprstimo"
	oSection2:Cell("PARCELA"):SetValue((cAliasQry)->E2_PARCELA)
	oSection2:Cell("VENC"):SetValue(dDtvenc)	
	oSection2:Cell("DEBITO"):SetValue(nValDeb)
	oSection2:Cell("JUROS"):SetValue((cAliasQry)->E2_JUROS)				
	oSection2:Cell("CORRIG"):SetValue(nValCorr)
	oSection2:Cell("AMORTIZ"):SetValue(nValor)
	oSection2:Cell("PRESTA"):SetValue(nValPres)
	oSection2:Cell("PRESTA"):SetValue(nValPres)
	oSection2:Cell("SALDO"):SetValue(nSaldo)						
	oSection2:Printline()
	
	// atualiza valor do debito	
	//If nValor > 0
		//nValDeb := nValDeb - (nValor - (cAliasQry)->E2_JUROS)
	//Else
		nValDeb := nValDeb - nValor
	//EndIf
	nTotJur  += (cAliasQry)->E2_JUROS
	nTotPres += nValPres
	
	(cAliasQry)->( dbSkip() )
	
EndDo

nSaldo := SEH->EH_SALDO
// Imprime totais do emprestimo
oSection2:Cell("PARCELA"):SetValue("Total")
oSection2:Cell("VENC"):SetValue(dDataIni)	
oSection2:Cell("DEBITO"):SetValue(0)
oSection2:Cell("JUROS"):SetValue(nTotJur)			
oSection2:Cell("CORRIG"):SetValue(0)	
oSection2:Cell("AMORTIZ"):SetValue(SEH->EH_FINANC)
oSection2:Cell("PRESTA"):SetValue(nTotPres)
oSection2:Cell("SALDO"):SetValue(nSaldo)					
oSection2:Printline()

// Finalizo a segunda seo para que seja reiniciada para o proximo registro
oSection2:Finish()
	
// Imprimo uma linha para separar as informaes
oReport:ThinLine()
	
//Finalizo a primeira seo
oSection1:Finish()

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCExcluiE2
Funo para excluso das parcelas no contas a pagar (SE2)

@author    Ronaldo Tapia
@version   11.80
@since     12/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FCExcluiE2(cNumero,nOpc)

Local cParcela	:= ""
Local aArea		:= GetArea()
Local nTamFor	:= TamSX3("E2_FORNECE")[1]
Local cForPar	:= PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"),nTamFor)
Local nI		:= 0

Default cNumero := SEH->EH_NUMERO  
Default nOpc    := 5

If SEH->EH_GERPARC == "1" .AND. empty(cForPar) 
	cForPar := Fa171Forn(cNumero)
EndIf

//Carrega as parcelas no arquivo temporario
FC171Par(cNumero,nOpc)

// Posiciona no arquivo correto da SEH
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

For nI := 1 To Len(bLoadGrd)

	cParcela := bLoadGrd[nI][2][1]

	dbSelectArea("SE2")
	SE2->(dbSetOrder(1))	//Prefixo+Numero+Parcela
	If !(SE2->(DbSeek(xFilial("SE2")+"EMP"+cNumero)))
		Exit
	Endif
	
	BEGIN TRANSACTION
		// Deleta registro
		If cParcela <> 999 .AND. SE2->E2_NATUREZ == SEH->EH_NATUREZ .AND. SE2->E2_FORNECE ==  cForPar .AND. Alltrim(SE2->E2_ORIGEM) $ "XFINA171|FINA050"
			// Deleta registro atual
			RecLock("SE2",.F.)
			dbDelete()
			MsUnLock()
		EndIf
	END TRANSACTION	 
	       
Next nI

RestArea(aArea)

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171Fornece
Funo para definir o fornecedor para gerao das parcelas provisrias

@author    Ronaldo Tapia
@version   11.80
@since     19/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FC171Fornece()

Local aRet		:= {}
Local aParamBox	:= {}
Local nTamFor	:= TamSX3("A2_COD")[1]

SaveInter() // Salva as variaveis publicas

// Define fornecedor para gerao das parcelas
aAdd( aParamBox, { 1, "Fornecedor", Space(nTamFor), "", "ExistCpo('SA2')", "SA2", "", 0, .T. } )

If ParamBox( aParamBox, "Definir Fornecedor", @aRet )
	cCodFor	:= PadR( mv_par01, nTamFor )
	cForLj	:= SA2->A2_LOJA
EndIf

If !SA2->( DbSeek( xFilial("SA2") + cCodFor + cForLj ) )
	MsgInfo(STR0025+cCodFor+STR0026,STR0017) //"Fornecedor: " //" no encontrado." //"Emprestimo Financeiro"
	cCodFor	:= ""
	cForLj	:= ""
EndIf

RestInter() // Restaura as variavis publicas

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCl171Emp
Valicacao dos campos pertencentes a aplicacao

@author    Ronaldo Tapia
@version   11.80
@since     19/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

STATIC Function FCl171Emp()
Local aArea    := { Alias() , IndexOrd() , Recno() }
Local lRetorna := .F.

If ( INCLUI .And. M->EH_APLEMP=="EMP" .And. M->EH_GERPARC == "1")
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return( lRetorna )

//------------------------------------------------------------------------------------------
/* {Protheus.doc} Fa171ETx
Valicacao nos campos EH_NBANCO e EH_TAXA

@author    Ronaldo Tapia
@version   11.80
@since     19/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

STATIC Function Fa171ETx()
Local aArea    := { Alias() , IndexOrd() , Recno() }
Local lRetorna := .F.

If ( ALTERA .And. M->EH_APLEMP=="EMP" .And. M->EH_GERPARC == "1")
	lRetorna := .F.
Else
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return( lRetorna )

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCAtuOK
Atualiza a tela para poder realizar a gravao das parcelas do grid

@author    Ronaldo Tapia
@version   11.80
@since     20/07/2016
@protected
@obs       Como  apenas visualizao da VIEW  necessrio forar uma
atualizao na tela para liberar a gravao (Boto Confirmar).
*/
//------------------------------------------------------------------------------------------

STATIC Function FCAtuOK()

Local lRet   := .T.
Local oModel := FWModelActive()
Local oGrid  := oModel:GetModel('FLYDETAIL')
Local oView  := FWViewActive()
Local nI     := 1
Local nTamFor	:= TamSX3("E2_FORNECE")[1]
Local cForPar	:= PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"),nTamFor)

If Empty(cCodFor) .AND. Empty(cForLj)
	DbSelectArea("SA2")
	SA2->(DbSetOrder(1))
	
	If SA2->( DbSeek( xFilial("SA2") + cForPar ) )
		cCodFor	:= SA2->A2_COD
		cForLj		:= SA2->A2_LOJA
	Else
		Aviso( STR0049, STR0050 + STR0037 + STR0051/*cMensagem*/, {"Ok"} )// #Ateno! #"No foi definido fornecedor para esta operao. Utilize o Boto '" #"Definir Fornecedor" #"' no menu ou atravs do parmetro MV_FOREMPR."
		lRet	:= .F.
	EndIf
EndIf

For nI := 1 To oGrid:Length()
	oGrid:GoLine( nI )
	If !oGrid:IsDeleted()
		oGrid:DeleteLine()
		oGrid:UnDeleteLine()
		Exit
	EndIf
Next nI

// Atualiza a tela
oView:Refresh()

Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa171Idx()
Funo para cadastro dos ndices que sero considerados para clculo do
rendimento da caderneta de poupana. (futuramente, para outras aplicaes)

@author Pedro Pereira Lima
@since 17/12/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------
STATIC Function Fa171Idx()
	Local oBrowse	As Object
	Local aRotBkp	As Array

	aRotBkp := aClone( aRotina )

	aRotina := {	{ STR0001	,"AxPesqui"	, 0 , 1, 0,.F.},;          
					{ STR0002	,"AxVisual"	, 0 , 2, 0,NIL},;          
					{ STR0003	,"AxInclui"	, 0 , 3, 0,NIL},;        
					{ STR0004	,"AxAltera"	, 0 , 4, 2,NIL},;     
					{ STR0005	,"AxDeleta"	, 0 , 5, 3,NIL}}

	oBrowse := FwMBrowse():New()

	oBrowse:SetAlias( 'FO3' )

	oBrowse:SetDescription( STR0066 )

	oBrowse:Activate()

	aRotina := aClone( aRotBkp )

	aRotBkp := {}

Return

//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa171RetPc()
Funo de inicializao do campo FO3_PERC (Percentual da Meta Selic)

@author Pedro Pereira Lima
@since 21/12/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------
STATIC Function Fa171RetPc() As Numeric
	Local nPerc As Numeric

	nPerc := SuperGetMV( 'MV_PERCSLM', .F., 70 )

Return nPerc


//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa171Forn()
Funo para busca do fornecedor usado para criar parcelas no emprstimo

@author Alberto Teixeira
@since 05/04/2019
@version 12.1.23
/*/
//--------------------------------------------------------------------------
STATIC Function Fa171Forn(cNumero)

Local cPrefixo	:= "EMP"
Local cFornece	:= ""
Local aAreaSE2	:= SE2->(GetArea())

	dbSelectArea("SE2")
	SE2->(DBSetOrder(1))
	If SE2->(MsSeek(xFilial("SE2")+cPrefixo+cNumero))
		cFornece := E2_FORNECE
	Else
		AVISO(STR0049,STR0067,{"Ok"}) //"Ateno!" //"Fornecedor no encontrado, verifique se o mesmo esta cadastrado na SA2."  
	EndIf	

RestArea(aAreaSE2)
Return (cFornece)
